{"version":3,"sources":["ng://chess-ts/lib/chess-enums.ts","ng://chess-ts/lib/chess.ts"],"names":["WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","from","to","promotion","this","Chess","fen","EMPTY","onChange","EventEmitter","SYMBOLS","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","Colour","castling","ep_square","half_moves","move_number","history","header","load","prototype","clear","update_setup","generate_fen","reset","tokens","split","position","validate_fen","valid","i","length","piece","charAt","is_digit","parseInt","color","put","type","toLowerCase","algebraic","indexOf","emit","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","undefined","toUpperCase","cflags","epflags","join","set_header","args","get","sq","PieceType","remove","build_move","flags","move","captured","add_move","moves","rank","push","pieces","len","generate_moves","options","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","square1","j","offset","castling_to","castling_from","attacked","legal_moves","make_move","king_attacked","undo_move","move_to_san","sloppy","output","disambiguator","get_disambiguator","in_check","in_checkmate","stripped_san","replace","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","pop","castling_to2","castling_from2","old","ambiguities","same_rank","same_file","ambig_from","ambig_to","file","ascii","s","move_from_san","clean_move","matches","match","f","substring","c","make_pretty","ugly_move","clone","san","obj","dupe","property","trim","str","perft","depth","nodes","getSquares","keys","getMoves","ugly_moves","verbose","Object","defineProperty","getPgn","newline","newline_char","max_width","result","header_exists","reversed_history","move_string","Result","current_width","i2","load_pgn","pgn","mask","regex","RegExp","header_string","headers","hOptions","hNewline_char","header_obj","lHeaders","key","value","parse_pgn_header","ms","rav_regex","half_move","object","has_keys","getHeader","arguments","move_obj","pretty_move","undo","square_color","sq_0x88","getHistory","move_history"],"mappings":"+QAYIA,MAAQ,IACRC,MAAQ,QAIRC,KAAO,IACPC,OAAS,IACTC,OAAS,IACTC,KAAO,IACPC,MAAQ,IACRC,KAAO,kBAMX,OAFI,SAAmBC,EAAqBC,EAC7BC,GADQC,KAAAH,KAAAA,EAAqBG,KAAAF,GAAAA,EAC7BE,KAAAD,UAAAA,MC3BfE,EAAA,WA2HI,SAAAA,EAAYC,GAtHLF,KAAAG,OAAS,EACTH,KAAAI,SAA+B,IAAIC,EAAAA,aAG1CL,KAAAM,QAAU,eAEVN,KAAAO,iBAAmB,2DAEnBP,KAAAQ,iBAAmB,CAAC,MAAO,MAAO,UAAW,KAE7CR,KAAAS,aAAe,CACXC,EAAG,CAAC,GAAI,GAAI,GAAI,IAChBC,EAAG,EAAE,IAAK,IAAK,IAAK,KAGxBX,KAAAY,cAAgB,CACZC,EAAG,EAAE,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IACpCH,EAAG,EAAE,IAAK,GAAI,GAAI,IAClBI,EAAG,EAAE,GAAI,EAAG,IAAK,GACjBC,EAAG,EAAE,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,GACnCC,EAAG,EAAE,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAGvChB,KAAAiB,QAAU,CACN,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAGhDjB,KAAAkB,KAAO,CACH,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAA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","sourcesContent":["\n/* todo:\n    make async and sync alternatives to the calling.\n    bring enums into the chess.ts file.\n    fix public/private variables\n    make sure everything has an explicit type\n    create separate classes game, fen, piece\n    fix the todos\n    add documentation and generate API doc\n*/\n\nexport enum Colour {\n    WHITE = 'w',\n    BLACK = 'b'\n}\n\nexport enum PieceType {\n    PAWN = 'p',\n    KNIGHT = 'n',\n    BISHOP = 'b',\n    ROOK = 'r',\n    QUEEN = 'q',\n    KING = 'k'\n}\n\nexport class Move {\n    constructor(public from: string, public to: string,\n        public promotion?: string) {}\n}","import { Colour, PieceType, Move } from './chess-enums';\nimport { EventEmitter } from '@angular/core';\n\nexport class Chess {\n\n    public EMPTY = -1;\n    public onChange: EventEmitter<void> = new EventEmitter<void>();\n\n\n    SYMBOLS = 'pnbrqkPNBRQK';\n\n    DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n\n    POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n\n    PAWN_OFFSETS = {\n        b: [16, 32, 17, 15],\n        w: [-16, -32, -17, -15]\n    };\n\n    PIECE_OFFSETS = {\n        n: [-18, -33, -31, -14, 18, 33, 31, 14],\n        b: [-17, -15, 17, 15],\n        r: [-16, 1, 16, -1],\n        q: [-17, -16, -15, 1, 17, 16, 15, -1],\n        k: [-17, -16, -15, 1, 17, 16, 15, -1]\n    };\n\n    ATTACKS = [\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n        24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n    ];\n\n    RAYS = [\n        17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n        0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n        0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n        0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n        0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n        1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n        0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n        0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n        0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n        0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n        -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n    ];\n\n    SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };\n\n    public FLAGS = {\n        NORMAL: 'n',\n        CAPTURE: 'c',\n        BIG_PAWN: 'b',\n        EP_CAPTURE: 'e',\n        PROMOTION: 'p',\n        KSIDE_CASTLE: 'k',\n        QSIDE_CASTLE: 'q'\n    };\n\n    BITS = {\n        NORMAL: 1,\n        CAPTURE: 2,\n        BIG_PAWN: 4,\n        EP_CAPTURE: 8,\n        PROMOTION: 16,\n        KSIDE_CASTLE: 32,\n        QSIDE_CASTLE: 64\n    };\n\n    RANK_1 = 7;\n    RANK_2 = 6;\n    RANK_3 = 5;\n    RANK_4 = 4;\n    RANK_5 = 3;\n    RANK_6 = 2;\n    RANK_7 = 1;\n    RANK_8 = 0;\n\n    SQUARES = {\n        a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n        a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n        a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n        a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n        a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n        a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n        a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n        a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n    };\n\n    ROOKS = {\n        w: [{ square: this.SQUARES.a1, flag: this.BITS.QSIDE_CASTLE },\n        { square: this.SQUARES.h1, flag: this.BITS.KSIDE_CASTLE }],\n        b: [{ square: this.SQUARES.a8, flag: this.BITS.QSIDE_CASTLE },\n        { square: this.SQUARES.h8, flag: this.BITS.KSIDE_CASTLE }]\n    };\n\n    board = new Array<ChessPiece>(128);\n    kings = { w: this.EMPTY, b: this.EMPTY };\n    public turn = Colour.WHITE;\n    castling: Castling = { w: 0, b: 0 };\n    ep_square = this.EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    header: any = {};\n\n    constructor(fen?: string) {\n        /* if the user passes in a fen string, load it, else default to\n         * starting position\n         */\n        if (typeof fen === 'undefined') {\n            this.load(this.DEFAULT_POSITION);\n        } else {\n            this.load(fen);\n        }\n    }\n\n    public clear() {\n        this.board = new Array(128);\n        this.kings = { w: this.EMPTY, b: this.EMPTY };\n        this.turn = Colour.WHITE;\n        this.castling = { w: 0, b: 0 };\n        this.ep_square = this.EMPTY;\n        this.half_moves = 0;\n        this.move_number = 1;\n        this.history = [];\n        this.header = {};\n        this.update_setup(this.generate_fen());\n    }\n\n    public reset() {\n        this.load(this.DEFAULT_POSITION);\n    }\n\n    public load(fen) {\n        const tokens = fen.split(/\\s+/);\n        const position = tokens[0];\n        let square = 0;\n\n        if (!this.validate_fen(fen).valid) {\n            return false;\n        }\n\n        this.clear();\n\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n\n            if (piece === '/') {\n                square += 8;\n            } else if (this.is_digit(piece)) {\n                square += parseInt(piece, 10);\n            } else {\n                const color = (piece < 'a') ? Colour.WHITE : Colour.BLACK;\n                this.put({ type: piece.toLowerCase(), color: color }, this.algebraic(square));\n                square++;\n            }\n        }\n\n        this.turn = tokens[1];\n\n        if (tokens[2].indexOf('K') > -1) {\n            this.castling.w |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this.castling.w |= this.BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this.castling.b |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this.castling.b |= this.BITS.QSIDE_CASTLE;\n        }\n\n        this.ep_square = (tokens[3] === '-') ? this.EMPTY : this.SQUARES[tokens[3]];\n        this.half_moves = parseInt(tokens[4], 10);\n        this.move_number = parseInt(tokens[5], 10);\n\n        this.update_setup(this.generate_fen());\n        this.onChange.emit();\n        return true;\n    }\n\n    /* TODO: this function is pretty much crap - it validates structure but\n     * completely ignores content (e.g. doesn't verify that each side has a king)\n     * ... we should rewrite this, and ditch the silly error_number field while\n     * we're at it\n     */\n    public validate_fen(fen): FenValidationResult {\n        const errors = {\n            0: 'No errors.',\n            1: 'FEN string must contain six space-delimited fields.',\n            2: '6th field (move number) must be a positive integer.',\n            3: '5th field (half move counter) must be a non-negative integer.',\n            4: '4th field (en-passant square) is invalid.',\n            5: '3rd field (castling availability) is invalid.',\n            6: '2nd field (side to move) is invalid.',\n            7: '1st field (piece positions) does not contain 8 \\'/\\'-delimited rows.',\n            8: '1st field (piece positions) is invalid [consecutive numbers].',\n            9: '1st field (piece positions) is invalid [invalid piece].',\n            10: '1st field (piece positions) is invalid [row too large].',\n            11: 'Illegal en-passant square',\n        };\n\n        /* 1st criterion: 6 space-seperated fields? */\n        const tokens = fen.split(/\\s+/);\n        if (tokens.length !== 6) {\n            return { valid: false, error_number: 1, error: errors[1] };\n        }\n\n        /* 2nd criterion: move number field is a integer value > 0? */\n        if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {\n            return { valid: false, error_number: 2, error: errors[2] };\n        }\n\n        /* 3rd criterion: half move counter is an integer >= 0? */\n        if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {\n            return { valid: false, error_number: 3, error: errors[3] };\n        }\n\n        /* 4th criterion: 4th field is a valid e.p.-string? */\n        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n            return { valid: false, error_number: 4, error: errors[4] };\n        }\n\n        /* 5th criterion: 3th field is a valid castle-string? */\n        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n            return { valid: false, error_number: 5, error: errors[5] };\n        }\n\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n        if (!/^(w|b)$/.test(tokens[1])) {\n            return { valid: false, error_number: 6, error: errors[6] };\n        }\n\n        /* 7th criterion: 1st field contains 8 rows? */\n        const rows = tokens[0].split('/');\n        if (rows.length !== 8) {\n            return { valid: false, error_number: 7, error: errors[7] };\n        }\n\n        /* 8th criterion: every row is valid? */\n        for (let i = 0; i < rows.length; i++) {\n            /* check for right sum of fields AND not two numbers in succession */\n            let sum_fields = 0;\n            let previous_was_number = false;\n\n            for (let k = 0; k < rows[i].length; k++) {\n                if (!isNaN(rows[i][k])) {\n                    if (previous_was_number) {\n                        return { valid: false, error_number: 8, error: errors[8] };\n                    }\n                    sum_fields += parseInt(rows[i][k], 10);\n                    previous_was_number = true;\n                } else {\n                    if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                        return { valid: false, error_number: 9, error: errors[9] };\n                    }\n                    sum_fields += 1;\n                    previous_was_number = false;\n                }\n            }\n            if (sum_fields !== 8) {\n                return { valid: false, error_number: 10, error: errors[10] };\n            }\n        }\n\n        if ((tokens[3][1] === '3' && tokens[1] === 'w') ||\n            (tokens[3][1] === '6' && tokens[1] === 'b')) {\n            return { valid: false, error_number: 11, error: errors[11] };\n        }\n\n        /* everything's okay! */\n        return { valid: true, error_number: 0, error: errors[0] };\n    }\n\n    generate_fen() {\n        let empty = 0;\n        let fen = '';\n\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (this.board[i] === undefined) {\n                empty++;\n            } else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const color = this.board[i].color;\n                const piece = this.board[i].type;\n\n                fen += (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n            }\n\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n\n                if (i !== this.SQUARES.h1) {\n                    fen += '/';\n                }\n\n                empty = 0;\n                i += 8;\n            }\n        }\n\n        let cflags = '';\n        if (this.castling[Colour.WHITE] & this.BITS.KSIDE_CASTLE) { cflags += 'K'; }\n        if (this.castling[Colour.WHITE] & this.BITS.QSIDE_CASTLE) { cflags += 'Q'; }\n        if (this.castling[Colour.BLACK] & this.BITS.KSIDE_CASTLE) { cflags += 'k'; }\n        if (this.castling[Colour.BLACK] & this.BITS.QSIDE_CASTLE) { cflags += 'q'; }\n\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        const epflags = (this.ep_square === this.EMPTY) ? '-' : this.algebraic(this.ep_square);\n\n        return [fen, this.turn, cflags, epflags, this.half_moves, this.move_number].join(' ');\n    }\n\n    set_header(args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' &&\n                typeof args[i + 1] === 'string') {\n                this.header[args[i]] = args[i + 1];\n            }\n        }\n        return this.header;\n    }\n\n    /* called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\n     * equal to the default position, the SetUp and FEN are deleted\n     * the setup is only updated if history.length is zero, ie moves haven't been\n     * made.\n     */\n    update_setup(fen) {\n        if (history.length > 0) { return; }\n\n        if (fen !== this.DEFAULT_POSITION) {\n            this.header['SetUp'] = '1';\n            this.header['FEN'] = fen;\n        } else {\n            delete this.header['SetUp'];\n            delete this.header['FEN'];\n        }\n    }\n\n    public get(square) {\n        const piece = this.board[this.SQUARES[square]];\n        return (piece) ? { type: piece.type, color: piece.color } : undefined;\n    }\n\n    public put(piece, square) {\n        /* check for valid piece object */\n        if (!('type' in piece && 'color' in piece)) {\n            return false;\n        }\n\n        /* check for piece */\n        if (this.SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n            return false;\n        }\n\n        /* check for valid square */\n        if (!(square in this.SQUARES)) {\n            return false;\n        }\n\n        const sq = this.SQUARES[square];\n\n        /* don't let the user place more than one king */\n        if (piece.type === PieceType.KING &&\n            !(this.kings[piece.color] === this.EMPTY || this.kings[piece.color] === sq)) {\n            return false;\n        }\n\n        this.board[sq] = { type: piece.type, color: piece.color };\n        if (piece.type === PieceType.KING) {\n            this.kings[piece.color] = sq;\n        }\n\n        this.update_setup(this.generate_fen());\n        return true;\n    }\n\n    public remove(square) {\n        const piece = this.get(square);\n        this.board[this.SQUARES[square]] = undefined;\n        if (piece && piece.type === PieceType.KING) {\n            this.kings[piece.color] = this.EMPTY;\n        }\n\n        this.update_setup(this.generate_fen());\n        return piece;\n    }\n\n    build_move(board, from, to, flags, promotion?) {\n        const move = {\n            color: this.turn,\n            from: from,\n            to: to,\n            flags: flags,\n            piece: board[from].type,\n            // dgm: these needed to exist for typescript\n            promotion: undefined,\n            captured: undefined\n        };\n\n        if (promotion) {\n            move.flags |= this.BITS.PROMOTION;\n            move.promotion = promotion;\n        }\n\n        if (board[to]) {\n            move.captured = board[to].type;\n        } else if (flags & this.BITS.EP_CAPTURE) {\n            move.captured = PieceType.PAWN;\n        }\n        return move;\n    }\n\n    private add_move(board, moves, from, to, flags) {\n        /* if pawn promotion */\n        if (board[from].type === PieceType.PAWN &&\n            (this.rank(to) === this.RANK_8 || this.rank(to) === this.RANK_1)) {\n            const pieces = [PieceType.QUEEN, PieceType.ROOK, PieceType.BISHOP, PieceType.KNIGHT];\n            for (let i = 0, len = pieces.length; i < len; i++) {\n                moves.push(this.build_move(board, from, to, flags, pieces[i]));\n            }\n        } else {\n            moves.push(this.build_move(board, from, to, flags));\n        }\n    }\n\n    generate_moves(options?) {\n\n\n        const moves = [];\n        const us = this.turn;\n        const them = this.swap_color(us);\n        const second_rank = { b: this.RANK_7, w: this.RANK_2 };\n\n        let first_sq = this.SQUARES.a8;\n        let last_sq = this.SQUARES.h1;\n        let single_square = false;\n\n        /* do we want legal moves? */\n        const legal = (typeof options !== 'undefined' && 'legal' in options) ?\n            options.legal : true;\n\n        /* are we generating moves for a single square? */\n        if (typeof options !== 'undefined' && 'square' in options) {\n            if (options.square in this.SQUARES) {\n                first_sq = last_sq = this.SQUARES[options.square];\n                single_square = true;\n            } else {\n                /* invalid square */\n                return [];\n            }\n        }\n\n        for (let i = first_sq; i <= last_sq; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) { i += 7; continue; }\n\n            const piece = this.board[i];\n            if (piece === undefined || piece.color !== us) {\n                continue;\n            }\n\n            if (piece.type === PieceType.PAWN) {\n                /* single square, non-capturing */\n                const square1 = i + this.PAWN_OFFSETS[us][0];\n                if (this.board[square1] === undefined) {\n                    this.add_move(this.board, moves, i, square1, this.BITS.NORMAL);\n\n                    /* double square */\n                    const square = i + this.PAWN_OFFSETS[us][1];\n                    if (second_rank[us] === this.rank(i) && this.board[square] === undefined) {\n                        this.add_move(this.board, moves, i, square, this.BITS.BIG_PAWN);\n                    }\n                }\n\n                /* pawn captures */\n                for (let j = 2; j < 4; j++) {\n                    const square = i + this.PAWN_OFFSETS[us][j];\n                    if (square & 0x88) { continue; }\n\n                    if (this.board[square] !== undefined &&\n                        this.board[square].color === them) {\n                        this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                    } else if (square === this.ep_square) {\n                        this.add_move(this.board, moves, i, this.ep_square, this.BITS.EP_CAPTURE);\n                    }\n                }\n            } else {\n                for (let j = 0, len = this.PIECE_OFFSETS[piece.type].length; j < len; j++) {\n                    const offset = this.PIECE_OFFSETS[piece.type][j];\n                    let square = i;\n\n                    while (true) {\n                        square += offset;\n                        if (square & 0x88) { break; }\n\n                        if (this.board[square] === undefined) {\n                            this.add_move(this.board, moves, i, square, this.BITS.NORMAL);\n                        } else {\n                            if (this.board[square].color === us) { break; }\n                            this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                            break;\n                        }\n\n                        /* break, if knight or king */\n                        if (piece.type === 'n' || piece.type === 'k') { break; }\n                    }\n                }\n            }\n        }\n\n        /* check for castling if: a) we're generating all moves, or b) we're doing\n         * single square move generation on the king's square\n         */\n        if ((!single_square) || last_sq === this.kings[us]) {\n            /* king-side castling */\n            if (this.castling[us] & this.BITS.KSIDE_CASTLE) {\n                const castling_from = this.kings[us];\n                const castling_to = castling_from + 2;\n\n                if (this.board[castling_from + 1] === undefined &&\n                    this.board[castling_to] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from + 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to,\n                        this.BITS.KSIDE_CASTLE);\n                }\n            }\n\n            /* queen-side castling */\n            if (this.castling[us] & this.BITS.QSIDE_CASTLE) {\n                const castling_from = this.kings[us];\n                const castling_to = castling_from - 2;\n\n                if (this.board[castling_from - 1] === undefined &&\n                    this.board[castling_from - 2] === undefined &&\n                    this.board[castling_from - 3] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from - 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to,\n                        this.BITS.QSIDE_CASTLE);\n                }\n            }\n        }\n\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves;\n        }\n\n        /* filter out illegal moves */\n        const legal_moves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(us)) {\n                legal_moves.push(moves[i]);\n            }\n            this.undo_move();\n        }\n\n        return legal_moves;\n    }\n\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n     * disambiguation bugs in Fritz and Chessbase.  See below:\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    move_to_san(move, sloppy?) {\n\n        let output = '';\n\n        if (move.flags & this.BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        } else {\n            const disambiguator = this.get_disambiguator(move, sloppy);\n\n            if (move.piece !== PieceType.PAWN) {\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n\n            if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n                if (move.piece === PieceType.PAWN) {\n                    output += this.algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n\n            output += this.algebraic(move.to);\n\n            if (move.flags & this.BITS.PROMOTION) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n\n        this.make_move(move);\n        if (this.in_check()) {\n            if (this.in_checkmate()) {\n                output += '#';\n            } else {\n                output += '+';\n            }\n        }\n        this.undo_move();\n\n        return output;\n    }\n\n    // parses all of the decorators out of a SAN string\n    stripped_san(move) {\n        return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n    }\n\n    attacked(color, square) {\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) { i += 7; continue; }\n\n            /* if empty square or wrong color */\n            if (this.board[i] === undefined || this.board[i].color !== color) { continue; }\n\n            const piece = this.board[i];\n            const difference = i - square;\n            const index = difference + 119;\n\n            if (this.ATTACKS[index] & (1 << this.SHIFTS[piece.type])) {\n                if (piece.type === PieceType.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === Colour.WHITE) { return true; }\n                    } else {\n                        if (piece.color === Colour.BLACK) { return true; }\n                    }\n                    continue;\n                }\n\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k') { return true; }\n\n                const offset = this.RAYS[index];\n                let j = i + offset;\n\n                let blocked = false;\n                while (j !== square) {\n                    if (this.board[j] !== undefined) { blocked = true; break; }\n                    j += offset;\n                }\n\n                if (!blocked) { return true; }\n            }\n        }\n\n        return false;\n    }\n\n    king_attacked(color) {\n        return this.attacked(this.swap_color(color), this.kings[color]);\n    }\n\n    public in_check() {\n        return this.king_attacked(this.turn);\n    }\n\n    public in_checkmate() {\n        return this.in_check() && this.generate_moves().length === 0;\n    }\n\n    public in_stalemate() {\n        return !this.in_check() && this.generate_moves().length === 0;\n    }\n\n    public insufficient_material() {\n        const pieces = {};\n        const bishops = [];\n        let num_pieces = 0;\n        let sq_color = 0;\n\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            sq_color = (sq_color + 1) % 2;\n            if (i & 0x88) { i += 7; continue; }\n\n            const piece = this.board[i];\n            if (piece) {\n                pieces[piece.type] = (piece.type in pieces) ?\n                    pieces[piece.type] + 1 : 1;\n                if (piece.type === PieceType.BISHOP) {\n                    bishops.push(sq_color);\n                }\n                num_pieces++;\n            }\n        }\n\n        /* k vs. k */\n        if (num_pieces === 2) { return true; } else if (num_pieces === 3 && (pieces[PieceType.BISHOP] === 1 ||\n            pieces[PieceType.KNIGHT] === 1)) { return true; } else if (num_pieces === pieces[PieceType.BISHOP] + 2) {\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) { return true; }\n        }\n\n        return false;\n    }\n\n    public in_threefold_repetition() {\n        /* TODO: while this function is fine for casual use, a better\n         * implementation would use a Zobrist key (instead of FEN). the\n         * Zobrist key would be maintained in the make_move/undo_move functions,\n         * avoiding the costly that we do below.\n         */\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n\n        while (true) {\n            const move = this.undo_move();\n            if (!move) { break; }\n            moves.push(move);\n        }\n\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            const fen = this.generate_fen().split(' ').slice(0, 4).join(' ');\n\n            /* has the position occurred three or move times */\n            positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n\n            if (!moves.length) {\n                break;\n            }\n            this.make_move(moves.pop());\n        }\n\n        return repetition;\n    }\n\n    push(move) {\n        this.history.push({\n            move: move,\n            kings: { b: this.kings.b, w: this.kings.w },\n            turn: this.turn,\n            castling: { b: this.castling.b, w: this.castling.w },\n            ep_square: this.ep_square,\n            half_moves: this.half_moves,\n            move_number: this.move_number\n        });\n    }\n\n    make_move(move) {\n        const us: Colour = this.turn;\n        const them = this.swap_color(us);\n        this.push(move);\n\n        this.board[move.to] = this.board[move.from];\n        this.board[move.from] = undefined;\n\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & this.BITS.EP_CAPTURE) {\n            if (this.turn === Colour.BLACK) {\n                this.board[move.to - 16] = undefined;\n            } else {\n                this.board[move.to + 16] = undefined;\n            }\n        }\n\n        /* if pawn promotion, replace with new piece */\n        if (move.flags & this.BITS.PROMOTION) {\n            this.board[move.to] = { type: move.promotion, color: us };\n        }\n\n        /* if we moved the king */\n        if (this.board[move.to].type === PieceType.KING) {\n            this.kings[this.board[move.to].color] = move.to;\n\n            /* if we castled, move the rook next to the king */\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                const castling_to = move.to - 1;\n                const castling_from = move.to + 1;\n                this.board[castling_to] = this.board[castling_from];\n                this.board[castling_from] = undefined;\n            } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                const castling_to2 = move.to + 1;\n                const castling_from2 = move.to - 2;\n                this.board[castling_to2] = this.board[castling_from2];\n                this.board[castling_from2] = undefined;\n            }\n\n            /* turn off castling */\n            this.castling[us] = '';\n        }\n\n        /* turn off castling if we move a rook */\n        if (this.castling[us]) {\n            for (let i = 0, len = this.ROOKS[us].length; i < len; i++) {\n                if (move.from === this.ROOKS[us][i].square &&\n                    this.castling[us] & this.ROOKS[us][i].flag) {\n                    this.castling[us] ^= this.ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n\n        /* turn off castling if we capture a rook */\n        if (this.castling[them]) {\n            for (let i = 0, len = this.ROOKS[them].length; i < len; i++) {\n                if (move.to === this.ROOKS[them][i].square &&\n                    this.castling[them] & this.ROOKS[them][i].flag) {\n                    this.castling[them] ^= this.ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n\n        /* if big pawn move, update the en passant square */\n        if (move.flags & this.BITS.BIG_PAWN) {\n            if (this.turn === 'b') {\n                this.ep_square = move.to - 16;\n            } else {\n                this.ep_square = move.to + 16;\n            }\n        } else {\n            this.ep_square = this.EMPTY;\n        }\n\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === PieceType.PAWN) {\n            this.half_moves = 0;\n        } else if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n            this.half_moves = 0;\n        } else {\n            this.half_moves++;\n        }\n\n        if (this.turn === Colour.BLACK) {\n            this.move_number++;\n        }\n        this.turn = this.swap_color(this.turn);\n    }\n\n    undo_move() {\n        const old = this.history.pop();\n        if (old === undefined) { return undefined; }\n\n        const move = old.move;\n        this.kings = old.kings;\n        this.turn = old.turn;\n        this.castling = old.castling;\n        this.ep_square = old.ep_square;\n        this.half_moves = old.half_moves;\n        this.move_number = old.move_number;\n\n        const us = this.turn;\n        const them = this.swap_color(this.turn);\n\n        this.board[move.from] = this.board[move.to];\n        this.board[move.from].type = move.piece;  // to undo any promotions\n        this.board[move.to] = undefined;\n\n        if (move.flags & this.BITS.CAPTURE) {\n            this.board[move.to] = { type: move.captured, color: them };\n        } else if (move.flags & this.BITS.EP_CAPTURE) {\n            let index;\n            if (us === Colour.BLACK) {\n                index = move.to - 16;\n            } else {\n                index = move.to + 16;\n            }\n            this.board[index] = { type: PieceType.PAWN, color: them };\n        }\n\n\n        if (move.flags & (this.BITS.KSIDE_CASTLE | this.BITS.QSIDE_CASTLE)) {\n            let castling_to, castling_from;\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                castling_to = move.to + 1;\n                castling_from = move.to - 1;\n            } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                castling_to = move.to - 2;\n                castling_from = move.to + 1;\n            }\n\n            this.board[castling_to] = this.board[castling_from];\n            this.board[castling_from] = undefined;\n        }\n        return move;\n    }\n\n    /* this function is used to uniquely identify ambiguous moves */\n    get_disambiguator(move, sloppy) {\n        const moves = this.generate_moves({ legal: !sloppy });\n\n        const from = move.from;\n        const to = move.to;\n        const piece = move.piece;\n\n        let ambiguities = 0;\n        let same_rank = 0;\n        let same_file = 0;\n\n        for (let i = 0, len = moves.length; i < len; i++) {\n            const ambig_from = moves[i].from;\n            const ambig_to = moves[i].to;\n            const ambig_piece = moves[i].piece;\n\n            /* if a move of the same piece type ends on the same to square, we'll\n             * need to add a disambiguator to the algebraic notation\n             */\n            if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n                ambiguities++;\n\n                if (this.rank(from) === this.rank(ambig_from)) {\n                    same_rank++;\n                }\n\n                if (this.file(from) === this.file(ambig_from)) {\n                    same_file++;\n                }\n            }\n        }\n\n        if (ambiguities > 0) {\n            /* if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            if (same_rank > 0 && same_file > 0) {\n                return this.algebraic(from);\n            } else if (same_file > 0) {\n                return this.algebraic(from).charAt(1);\n            } else {\n                return this.algebraic(from).charAt(0);\n            }\n        }\n\n        return '';\n    }\n\n    public ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* display the rank */\n            if (this.file(i) === 0) {\n                s += ' ' + '87654321'[this.rank(i)] + ' |';\n            }\n\n            /* empty piece */\n            if (this.board[i] === undefined) {\n                s += ' . ';\n            } else {\n                const piece = this.board[i].type;\n                const color = this.board[i].color;\n                const symbol = (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h\\n';\n\n        return s;\n    }\n\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    move_from_san(move, sloppy) {\n        // strip off any move decorations: e.g Nf3+?!\n        const clean_move = this.stripped_san(move);\n\n        // if we're using the sloppy parser run a regex to grab piece, to, and from\n        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n        const matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        let piece;\n        let from;\n        let to;\n        let promotion;\n        if (sloppy) {\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n            }\n        }\n\n        const moves = this.generate_moves();\n        for (let i = 0, len = moves.length; i < len; i++) {\n            // try the strict parser first, then the sloppy parser if requested\n            // by the user\n            if ((clean_move === this.stripped_san(this.move_to_san(moves[i]))) ||\n                (sloppy && clean_move === this.stripped_san(this.move_to_san(moves[i], true)))) {\n                return moves[i];\n            } else {\n                if (matches &&\n                    (!piece || piece.toLowerCase() === moves[i].piece) &&\n                    this.SQUARES[from] === moves[i].from &&\n                    this.SQUARES[to] === moves[i].to &&\n                    (!promotion || promotion.toLowerCase() === moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n\n    /*****************************************************************************\n     * UTILITY FUNCTIONS\n     ****************************************************************************/\n    rank(i) {\n        return i >> 4;\n    }\n\n    file(i) {\n        return i & 15;\n    }\n\n    algebraic(i) {\n        const f = this.file(i), r = this.rank(i);\n        return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n    }\n\n    swap_color(c) {\n        return c === Colour.WHITE ? Colour.BLACK : Colour.WHITE;\n    }\n\n    is_digit(c) {\n        return '0123456789'.indexOf(c) !== -1;\n    }\n\n    /* pretty = external move object */\n    make_pretty(ugly_move) {\n        const move = this.clone(ugly_move);\n        move.san = this.move_to_san(move, false);\n        move.to = this.algebraic(move.to);\n        move.from = this.algebraic(move.from);\n\n        let flags = '';\n\n        for (const flag in this.BITS) {\n            if (this.BITS[flag] & move.flags) {\n                flags += this.FLAGS[flag];\n            }\n        }\n        move.flags = flags;\n\n        return move;\n    }\n\n    clone(obj) {\n        const dupe: any = (obj instanceof Array) ? [] : {};\n\n        for (const property in obj) {\n            if (typeof property === 'object') {\n                dupe[property] = this.clone(obj[property]);\n            } else {\n                dupe[property] = obj[property];\n            }\n        }\n\n        return dupe;\n    }\n\n    trim(str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    /*****************************************************************************\n     * DEBUGGING UTILITIES\n     ****************************************************************************/\n    public perft(depth) {\n        const moves = this.generate_moves({ legal: false });\n        let nodes = 0;\n        const color = this.turn;\n\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(color)) {\n                if (depth - 1 > 0) {\n                    const child_nodes = this.perft(depth - 1);\n                    nodes += child_nodes;\n                } else {\n                    nodes++;\n                }\n            }\n            this.undo_move();\n        }\n\n        return nodes;\n    }\n\n    public getSquares() {\n        /* from the ECMA-262 spec (section 12.6.4):\n         * \"The mechanics of enumerating the properties ... is\n         * implementation dependent\"\n         * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n         * ordered correctly\n         */\n        const keys = [];\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (i & 0x88) { i += 7; continue; }\n            keys.push(this.algebraic(i));\n        }\n        return keys;\n    }\n\n    public getMoves(options) {\n        /* The internal representation of a chess move is in 0x88 format, and\n                 * not meant to be human-readable.  The code below converts the 0x88\n                 * square coordinates to algebraic coordinates.  It also prunes an\n                 * unnecessary move keys resulting from a verbose call.\n                 */\n\n        const ugly_moves = this.generate_moves(options);\n        const moves = [];\n\n        for (let i = 0, len = ugly_moves.length; i < len; i++) {\n\n            /* does the user want a full move object (most likely not), or just\n             * SAN\n             */\n            if (typeof options !== 'undefined' && 'verbose' in options &&\n                options.verbose) {\n                moves.push(this.make_pretty(ugly_moves[i]));\n            } else {\n                moves.push(this.move_to_san(ugly_moves[i], false));\n            }\n        }\n\n        return moves;\n    }\n\n    public get in_draw() {\n        return this.half_moves >= 100 ||\n            this.in_stalemate() ||\n            this.insufficient_material() ||\n            this.in_threefold_repetition();\n    }\n\n    public get game_over() {\n        return this.half_moves >= 100 ||\n            this.in_checkmate() ||\n            this.in_stalemate() ||\n            this.insufficient_material() ||\n            this.in_threefold_repetition();\n    }\n\n    public get fen() {\n        return this.generate_fen();\n    }\n\n    public getPgn(options) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n                 * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n                 */\n        const newline = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\n';\n        const max_width = (typeof options === 'object' &&\n            typeof options.max_width === 'number') ?\n            options.max_width : 0;\n        const result = [];\n        let header_exists = false;\n\n        /* add the PGN header headerrmation */\n        for (const i in this.header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \\\"' + this.header[i] + '\\\"]' + newline);\n            header_exists = true;\n        }\n\n        if (header_exists && history.length) {\n            result.push(newline);\n        }\n\n        /* pop all of history onto reversed_history */\n        const reversed_history = [];\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n\n        const moves = [];\n        let move_string = '';\n\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversed_history.length > 0) {\n            const move = reversed_history.pop();\n\n            /* if the position started with black to move, start PGN with 1. ... */\n            if (!history.length && move.color === 'b') {\n                move_string = this.move_number + '. ...';\n            } else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (move_string.length) {\n                    moves.push(move_string);\n                }\n                move_string = this.move_number + '.';\n            }\n\n            move_string = move_string + ' ' + this.move_to_san(move, false);\n            this.make_move(move);\n        }\n\n        /* are there any other leftover moves? */\n        if (move_string.length) {\n            moves.push(move_string);\n        }\n\n        /* is there a result? */\n        if (typeof this.header.Result !== 'undefined') {\n            moves.push(this.header.Result);\n        }\n\n        /* history should be back to what is was before we started generating PGN,\n         * so join together moves\n         */\n        if (max_width === 0) {\n            return result.join('') + moves.join(' ');\n        }\n\n        /* wrap the PGN output at max_width */\n        let current_width = 0;\n        for (let i2 = 0; i2 < moves.length; i2++) {\n            /* if the current move will push past max_width */\n            if (current_width + moves[i2].length > max_width && i2 !== 0) {\n\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n\n                result.push(newline);\n                current_width = 0;\n            } else if (i2 !== 0) {\n                result.push(' ');\n                current_width++;\n            }\n            result.push(moves[i2]);\n            current_width += moves[i2].length;\n        }\n\n        return result.join('');\n    }\n\n    public load_pgn(pgn, options) {\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        const sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n\n        function has_keys(object) {\n            for (const key in object) {\n                return true;\n            }\n            return false;\n        }\n\n        function parse_pgn_header(header, hOptions) {\n            const hNewline_char = (typeof hOptions === 'object' &&\n                typeof hOptions.newline_char === 'string') ?\n                hOptions.newline_char : '\\r?\\n';\n            const header_obj = {};\n            const lHeaders = header.split(new RegExp(mask(hNewline_char)));\n            let key = '';\n            let value = '';\n\n            for (let i = 0; i < lHeaders.length; i++) {\n                key = lHeaders[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n                value = lHeaders[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1');\n                if (this.trim(key).length > 0) {\n                    header_obj[key] = value;\n                }\n            }\n\n            return header_obj;\n        }\n\n        const newline_char = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\r?\\n';\n        const regex = new RegExp('^(\\\\[(.|' + mask(newline_char) + ')*\\\\])' +\n            '(' + mask(newline_char) + ')*' +\n            '1.(' + mask(newline_char) + '|.)*$', 'g');\n\n        /* get header part of the PGN file */\n        let header_string = pgn.replace(regex, '$1');\n\n        /* no info part given, begins with moves */\n        if (header_string[0] !== '[') {\n            header_string = '';\n        }\n\n        this.reset();\n\n        /* parse PGN header */\n        const headers = parse_pgn_header(header_string, options);\n        for (const key in headers) {\n            this.set_header([key, headers[key]]);\n        }\n\n        /* load the starting position indicated by [Setup '1'] and\n        * [FEN position] */\n        if (headers['SetUp'] === '1') {\n            if (!(('FEN' in headers) && this.load(headers['FEN']))) {\n                return false;\n            }\n        }\n\n        /* delete header to get the moves */\n        let ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');\n\n        /* delete comments */\n        ms = ms.replace(/(\\{[^}]+\\})+?/g, '');\n\n        /* delete recursive annotation variations */\n        const rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n        while (rav_regex.test(ms)) {\n            ms = ms.replace(rav_regex, '');\n        }\n\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n\n        /* trim and get array of moves */\n        let moves = this.trim(ms).split(new RegExp(/\\s+/));\n\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        let move = '';\n\n        for (let half_move = 0; half_move < moves.length - 1; half_move++) {\n            move = this.move_from_san(moves[half_move], sloppy);\n\n            /* move not possible! (don't clear the board to examine to show the\n             * latest valid position)\n             */\n            if (move === undefined) {\n                return false;\n            } else {\n                this.make_move(move);\n            }\n        }\n\n        /* examine last move */\n        move = moves[moves.length - 1];\n        if (this.POSSIBLE_RESULTS.indexOf(move) > -1) {\n            if (has_keys(this.header) && typeof this.header.Result === 'undefined') {\n                this.set_header(['Result', move]);\n            }\n        } else {\n            move = this.move_from_san(move, sloppy);\n            if (move === undefined) {\n                return false;\n            } else {\n                this.make_move(move);\n            }\n        }\n        return true;\n    }\n\n    public getHeader() {\n        return this.set_header(arguments);\n    }\n\n    public move(move: Move | string, options?) {\n        /* The move function can be called with in the following parameters:\n                 *\n                 * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n                 *\n                 * .move({ from: 'h7', <- where the 'move' is a move object (additional\n                 *         to :'h8',      fields are ignored)\n                 *         promotion: 'q',\n                 *      })\n                 */\n\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        const sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n\n        let move_obj;\n\n        if (typeof move === 'string') {\n            move_obj = this.move_from_san(move, sloppy);\n        } else if (typeof move === 'object') {\n            const moves = this.generate_moves();\n\n            /* convert the pretty move object to an ugly move object */\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === this.algebraic(moves[i].from) &&\n                    move.to === this.algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) ||\n                        move.promotion === moves[i].promotion)) {\n                    move_obj = moves[i];\n                    break;\n                }\n            }\n        }\n\n        /* failed to find move */\n        if (!move_obj) {\n            return undefined;\n        }\n\n        /* need to make a copy of move because we can't generate SAN after the\n         * move is made\n         */\n        const pretty_move = this.make_pretty(move_obj);\n\n        this.make_move(move_obj);\n        this.onChange.emit();\n        return pretty_move;\n    }\n\n    public undo() {\n        const move = this.undo_move();\n        this.onChange.emit();\n        return (move) ? this.make_pretty(move) : undefined;\n    }\n\n    public square_color(square) {\n        if (square in this.SQUARES) {\n            const sq_0x88 = this.SQUARES[square];\n            return ((this.rank(sq_0x88) + this.file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';\n        }\n\n        return undefined;\n    }\n\n    public getHistory(options) {\n        const reversed_history = [];\n        const move_history = [];\n        const verbose = (typeof options !== 'undefined' && 'verbose' in options &&\n            options.verbose);\n\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n\n        while (reversed_history.length > 0) {\n            const move = reversed_history.pop();\n            if (verbose) {\n                move_history.push(this.make_pretty(move));\n            } else {\n                move_history.push(this.move_to_san(move));\n            }\n            this.make_move(move);\n        }\n\n        return move_history;\n    }\n\n} // End of Chess class\n\nexport class FenValidationResult {\n    // { valid: true, error_number: 0, error: errors[0] };\n    valid: boolean;\n    error_number: number;\n    error: string;\n}\n\nexport class ChessPiece {\n    color;\n    type;\n}\n\n// enum Colour {\n//     WHITE = 'w',\n//     BLACK = 'b'\n// }\n\nclass Castling {\n    w: any;\n    b: any;\n}\n\n\n\n\n"]}