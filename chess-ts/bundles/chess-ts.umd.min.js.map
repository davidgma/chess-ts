{"version":3,"sources":["../../../projects/chess-ts/src/lib/chess-enums.ts","../../../projects/chess-ts/src/lib/chess.ts"],"names":["Colour","PieceType","from","to","promotion","this","Chess","fen","EMPTY","onChange","EventEmitter","SYMBOLS","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","WHITE","castling","ep_square","half_moves","move_number","history","header","load","prototype","clear","update_setup","generate_fen","reset","tokens","split","position","validate_fen","valid","i","length","piece","charAt","is_digit","parseInt","color","BLACK","put","type","toLowerCase","algebraic","indexOf","emit","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","undefined","toUpperCase","cflags","epflags","join","set_header","args","get","sq","KING","remove","build_move","flags","move","captured","PAWN","add_move","moves","rank","push","pieces","QUEEN","ROOK","BISHOP","KNIGHT","len","generate_moves","options","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","square1","j","offset","castling_to","castling_from","attacked","legal_moves","make_move","king_attacked","undo_move","move_to_san","sloppy","output","disambiguator","get_disambiguator","in_check","in_checkmate","stripped_san","replace","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","pop","castling_to2","castling_from2","old","ambiguities","same_rank","same_file","ambig_from","ambig_to","file","ascii","s","move_from_san","clean_move","matches","match","f","substring","c","make_pretty","ugly_move","clone","san","obj","dupe","property","trim","str","perft","depth","nodes","getSquares","keys","getMoves","ugly_moves","verbose","Object","defineProperty","getPgn","newline","newline_char","max_width","result","header_exists","reversed_history","move_string","Result","current_width","i2","load_pgn","pgn","mask","regex","RegExp","header_string","headers","hOptions","hNewline_char","header_obj","lHeaders","key","value","parse_pgn_header","ms","rav_regex","half_move","object","has_keys","getHeader","arguments","move_obj","pretty_move","undo","square_color","sq_0x88","getHistory","move_history"],"mappings":"mTAWA,IAAYA,EAKAC,GALAD,EAAAA,EAAAA,SAAAA,EAAAA,OAAM,KACd,MAAA,IACAA,EAAA,MAAA,KAGQC,EAAAA,EAAAA,YAAAA,EAAAA,UAAS,KACjB,KAAA,IACAA,EAAA,OAAA,IACAA,EAAA,OAAA,IACAA,EAAA,KAAA,IACAA,EAAA,MAAA,IACAA,EAAA,KAAA,UAIA,SAAmBC,EAAqBC,EAC7BC,GADQC,KAAAH,KAAAA,EAAqBG,KAAAF,GAAAA,EAC7BE,KAAAD,UAAAA,gBCgGX,SAAAE,EAAYC,GAtHLF,KAAAG,OAAS,EACTH,KAAAI,SAA+B,IAAIC,EAAAA,aAG1CL,KAAAM,QAAU,eAEVN,KAAAO,iBAAmB,2DAEnBP,KAAAQ,iBAAmB,CAAC,MAAO,MAAO,UAAW,KAE7CR,KAAAS,aAAe,CACXC,EAAG,CAAC,GAAI,GAAI,GAAI,IAChBC,EAAG,EAAE,IAAK,IAAK,IAAK,KAGxBX,KAAAY,cAAgB,CACZC,EAAG,EAAE,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IACpCH,EAAG,EAAE,IAAK,GAAI,GAAI,IAClBI,EAAG,EAAE,GAAI,EAAG,IAAK,GACjBC,EAAG,EAAE,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,GACnCC,EAAG,EAAE,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAGvChB,KAAAiB,QAAU,CACN,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAGhDjB,KAAAkB,KAAO,CACH,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,E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","sourcesContent":["\n/* todo:\n    make async and sync alternatives to the calling.\n    bring enums into the chess.ts file.\n    fix public/private variables\n    make sure everything has an explicit type\n    create separate classes game, fen, piece\n    fix the todos\n    add documentation and generate API doc\n*/\n\nexport enum Colour {\n    WHITE = 'w',\n    BLACK = 'b'\n}\n\nexport enum PieceType {\n    PAWN = 'p',\n    KNIGHT = 'n',\n    BISHOP = 'b',\n    ROOK = 'r',\n    QUEEN = 'q',\n    KING = 'k'\n}\n\nexport class Move {\n    constructor(public from: string, public to: string,\n        public promotion?: string) {}\n}","import { Colour, PieceType, Move } from './chess-enums';\nimport { EventEmitter } from '@angular/core';\n\nexport class Chess {\n\n    public EMPTY = -1;\n    public onChange: EventEmitter<void> = new EventEmitter<void>();\n\n\n    SYMBOLS = 'pnbrqkPNBRQK';\n\n    DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n\n    POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n\n    PAWN_OFFSETS = {\n        b: [16, 32, 17, 15],\n        w: [-16, -32, -17, -15]\n    };\n\n    PIECE_OFFSETS = {\n        n: [-18, -33, -31, -14, 18, 33, 31, 14],\n        b: [-17, -15, 17, 15],\n        r: [-16, 1, 16, -1],\n        q: [-17, -16, -15, 1, 17, 16, 15, -1],\n        k: [-17, -16, -15, 1, 17, 16, 15, -1]\n    };\n\n    ATTACKS = [\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n        24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n    ];\n\n    RAYS = [\n        17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n        0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n        0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n        0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n        0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n        1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n        0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n        0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n        0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n        0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n        -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n    ];\n\n    SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };\n\n    public FLAGS = {\n        NORMAL: 'n',\n        CAPTURE: 'c',\n        BIG_PAWN: 'b',\n        EP_CAPTURE: 'e',\n        PROMOTION: 'p',\n        KSIDE_CASTLE: 'k',\n        QSIDE_CASTLE: 'q'\n    };\n\n    BITS = {\n        NORMAL: 1,\n        CAPTURE: 2,\n        BIG_PAWN: 4,\n        EP_CAPTURE: 8,\n        PROMOTION: 16,\n        KSIDE_CASTLE: 32,\n        QSIDE_CASTLE: 64\n    };\n\n    RANK_1 = 7;\n    RANK_2 = 6;\n    RANK_3 = 5;\n    RANK_4 = 4;\n    RANK_5 = 3;\n    RANK_6 = 2;\n    RANK_7 = 1;\n    RANK_8 = 0;\n\n    SQUARES = {\n        a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n        a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n        a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n        a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n        a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n        a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n        a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n        a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n    };\n\n    ROOKS = {\n        w: [{ square: this.SQUARES.a1, flag: this.BITS.QSIDE_CASTLE },\n        { square: this.SQUARES.h1, flag: this.BITS.KSIDE_CASTLE }],\n        b: [{ square: this.SQUARES.a8, flag: this.BITS.QSIDE_CASTLE },\n        { square: this.SQUARES.h8, flag: this.BITS.KSIDE_CASTLE }]\n    };\n\n    board = new Array<ChessPiece>(128);\n    kings = { w: this.EMPTY, b: this.EMPTY };\n    public turn = Colour.WHITE;\n    castling: Castling = { w: 0, b: 0 };\n    ep_square = this.EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    header: any = {};\n\n    constructor(fen?: string) {\n        /* if the user passes in a fen string, load it, else default to\n         * starting position\n         */\n        if (typeof fen === 'undefined') {\n            this.load(this.DEFAULT_POSITION);\n        } else {\n            this.load(fen);\n        }\n    }\n\n    public clear() {\n        this.board = new Array(128);\n        this.kings = { w: this.EMPTY, b: this.EMPTY };\n        this.turn = Colour.WHITE;\n        this.castling = { w: 0, b: 0 };\n        this.ep_square = this.EMPTY;\n        this.half_moves = 0;\n        this.move_number = 1;\n        this.history = [];\n        this.header = {};\n        this.update_setup(this.generate_fen());\n    }\n\n    public reset() {\n        this.load(this.DEFAULT_POSITION);\n    }\n\n    public load(fen) {\n        const tokens = fen.split(/\\s+/);\n        const position = tokens[0];\n        let square = 0;\n\n        if (!this.validate_fen(fen).valid) {\n            return false;\n        }\n\n        this.clear();\n\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n\n            if (piece === '/') {\n                square += 8;\n            } else if (this.is_digit(piece)) {\n                square += parseInt(piece, 10);\n            } else {\n                const color = (piece < 'a') ? Colour.WHITE : Colour.BLACK;\n                this.put({ type: piece.toLowerCase(), color: color }, this.algebraic(square));\n                square++;\n            }\n        }\n\n        this.turn = tokens[1];\n\n        if (tokens[2].indexOf('K') > -1) {\n            this.castling.w |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this.castling.w |= this.BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this.castling.b |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this.castling.b |= this.BITS.QSIDE_CASTLE;\n        }\n\n        this.ep_square = (tokens[3] === '-') ? this.EMPTY : this.SQUARES[tokens[3]];\n        this.half_moves = parseInt(tokens[4], 10);\n        this.move_number = parseInt(tokens[5], 10);\n\n        this.update_setup(this.generate_fen());\n        this.onChange.emit();\n        return true;\n    }\n\n    /* TODO: this function is pretty much crap - it validates structure but\n     * completely ignores content (e.g. doesn't verify that each side has a king)\n     * ... we should rewrite this, and ditch the silly error_number field while\n     * we're at it\n     */\n    public validate_fen(fen): FenValidationResult {\n        const errors = {\n            0: 'No errors.',\n            1: 'FEN string must contain six space-delimited fields.',\n            2: '6th field (move number) must be a positive integer.',\n            3: '5th field (half move counter) must be a non-negative integer.',\n            4: '4th field (en-passant square) is invalid.',\n            5: '3rd field (castling availability) is invalid.',\n            6: '2nd field (side to move) is invalid.',\n            7: '1st field (piece positions) does not contain 8 \\'/\\'-delimited rows.',\n            8: '1st field (piece positions) is invalid [consecutive numbers].',\n            9: '1st field (piece positions) is invalid [invalid piece].',\n            10: '1st field (piece positions) is invalid [row too large].',\n            11: 'Illegal en-passant square',\n        };\n\n        /* 1st criterion: 6 space-seperated fields? */\n        const tokens = fen.split(/\\s+/);\n        if (tokens.length !== 6) {\n            return { valid: false, error_number: 1, error: errors[1] };\n        }\n\n        /* 2nd criterion: move number field is a integer value > 0? */\n        if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {\n            return { valid: false, error_number: 2, error: errors[2] };\n        }\n\n        /* 3rd criterion: half move counter is an integer >= 0? */\n        if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {\n            return { valid: false, error_number: 3, error: errors[3] };\n        }\n\n        /* 4th criterion: 4th field is a valid e.p.-string? */\n        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n            return { valid: false, error_number: 4, error: errors[4] };\n        }\n\n        /* 5th criterion: 3th field is a valid castle-string? */\n        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n            return { valid: false, error_number: 5, error: errors[5] };\n        }\n\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n        if (!/^(w|b)$/.test(tokens[1])) {\n            return { valid: false, error_number: 6, error: errors[6] };\n        }\n\n        /* 7th criterion: 1st field contains 8 rows? */\n        const rows = tokens[0].split('/');\n        if (rows.length !== 8) {\n            return { valid: false, error_number: 7, error: errors[7] };\n        }\n\n        /* 8th criterion: every row is valid? */\n        for (let i = 0; i < rows.length; i++) {\n            /* check for right sum of fields AND not two numbers in succession */\n            let sum_fields = 0;\n            let previous_was_number = false;\n\n            for (let k = 0; k < rows[i].length; k++) {\n                if (!isNaN(rows[i][k])) {\n                    if (previous_was_number) {\n                        return { valid: false, error_number: 8, error: errors[8] };\n                    }\n                    sum_fields += parseInt(rows[i][k], 10);\n                    previous_was_number = true;\n                } else {\n                    if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                        return { valid: false, error_number: 9, error: errors[9] };\n                    }\n                    sum_fields += 1;\n                    previous_was_number = false;\n                }\n            }\n            if (sum_fields !== 8) {\n                return { valid: false, error_number: 10, error: errors[10] };\n            }\n        }\n\n        if ((tokens[3][1] === '3' && tokens[1] === 'w') ||\n            (tokens[3][1] === '6' && tokens[1] === 'b')) {\n            return { valid: false, error_number: 11, error: errors[11] };\n        }\n\n        /* everything's okay! */\n        return { valid: true, error_number: 0, error: errors[0] };\n    }\n\n    generate_fen() {\n        let empty = 0;\n        let fen = '';\n\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (this.board[i] === undefined) {\n                empty++;\n            } else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const color = this.board[i].color;\n                const piece = this.board[i].type;\n\n                fen += (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n            }\n\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n\n                if (i !== this.SQUARES.h1) {\n                    fen += '/';\n                }\n\n                empty = 0;\n                i += 8;\n            }\n        }\n\n        let cflags = '';\n        if (this.castling[Colour.WHITE] & this.BITS.KSIDE_CASTLE) { cflags += 'K'; }\n        if (this.castling[Colour.WHITE] & this.BITS.QSIDE_CASTLE) { cflags += 'Q'; }\n        if (this.castling[Colour.BLACK] & this.BITS.KSIDE_CASTLE) { cflags += 'k'; }\n        if (this.castling[Colour.BLACK] & this.BITS.QSIDE_CASTLE) { cflags += 'q'; }\n\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        const epflags = (this.ep_square === this.EMPTY) ? '-' : this.algebraic(this.ep_square);\n\n        return [fen, this.turn, cflags, epflags, this.half_moves, this.move_number].join(' ');\n    }\n\n    set_header(args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' &&\n                typeof args[i + 1] === 'string') {\n                this.header[args[i]] = args[i + 1];\n            }\n        }\n        return this.header;\n    }\n\n    /* called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\n     * equal to the default position, the SetUp and FEN are deleted\n     * the setup is only updated if history.length is zero, ie moves haven't been\n     * made.\n     */\n    update_setup(fen) {\n        if (history.length > 0) { return; }\n\n        if (fen !== this.DEFAULT_POSITION) {\n            this.header['SetUp'] = '1';\n            this.header['FEN'] = fen;\n        } else {\n            delete this.header['SetUp'];\n            delete this.header['FEN'];\n        }\n    }\n\n    public get(square) {\n        const piece = this.board[this.SQUARES[square]];\n        return (piece) ? { type: piece.type, color: piece.color } : undefined;\n    }\n\n    public put(piece, square) {\n        /* check for valid piece object */\n        if (!('type' in piece && 'color' in piece)) {\n            return false;\n        }\n\n        /* check for piece */\n        if (this.SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n            return false;\n        }\n\n        /* check for valid square */\n        if (!(square in this.SQUARES)) {\n            return false;\n        }\n\n        const sq = this.SQUARES[square];\n\n        /* don't let the user place more than one king */\n        if (piece.type === PieceType.KING &&\n            !(this.kings[piece.color] === this.EMPTY || this.kings[piece.color] === sq)) {\n            return false;\n        }\n\n        this.board[sq] = { type: piece.type, color: piece.color };\n        if (piece.type === PieceType.KING) {\n            this.kings[piece.color] = sq;\n        }\n\n        this.update_setup(this.generate_fen());\n        return true;\n    }\n\n    public remove(square) {\n        const piece = this.get(square);\n        this.board[this.SQUARES[square]] = undefined;\n        if (piece && piece.type === PieceType.KING) {\n            this.kings[piece.color] = this.EMPTY;\n        }\n\n        this.update_setup(this.generate_fen());\n        return piece;\n    }\n\n    build_move(board, from, to, flags, promotion?) {\n        const move = {\n            color: this.turn,\n            from: from,\n            to: to,\n            flags: flags,\n            piece: board[from].type,\n            // dgm: these needed to exist for typescript\n            promotion: undefined,\n            captured: undefined\n        };\n\n        if (promotion) {\n            move.flags |= this.BITS.PROMOTION;\n            move.promotion = promotion;\n        }\n\n        if (board[to]) {\n            move.captured = board[to].type;\n        } else if (flags & this.BITS.EP_CAPTURE) {\n            move.captured = PieceType.PAWN;\n        }\n        return move;\n    }\n\n    private add_move(board, moves, from, to, flags) {\n        /* if pawn promotion */\n        if (board[from].type === PieceType.PAWN &&\n            (this.rank(to) === this.RANK_8 || this.rank(to) === this.RANK_1)) {\n            const pieces = [PieceType.QUEEN, PieceType.ROOK, PieceType.BISHOP, PieceType.KNIGHT];\n            for (let i = 0, len = pieces.length; i < len; i++) {\n                moves.push(this.build_move(board, from, to, flags, pieces[i]));\n            }\n        } else {\n            moves.push(this.build_move(board, from, to, flags));\n        }\n    }\n\n    generate_moves(options?) {\n\n\n        const moves = [];\n        const us = this.turn;\n        const them = this.swap_color(us);\n        const second_rank = { b: this.RANK_7, w: this.RANK_2 };\n\n        let first_sq = this.SQUARES.a8;\n        let last_sq = this.SQUARES.h1;\n        let single_square = false;\n\n        /* do we want legal moves? */\n        const legal = (typeof options !== 'undefined' && 'legal' in options) ?\n            options.legal : true;\n\n        /* are we generating moves for a single square? */\n        if (typeof options !== 'undefined' && 'square' in options) {\n            if (options.square in this.SQUARES) {\n                first_sq = last_sq = this.SQUARES[options.square];\n                single_square = true;\n            } else {\n                /* invalid square */\n                return [];\n            }\n        }\n\n        for (let i = first_sq; i <= last_sq; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) { i += 7; continue; }\n\n            const piece = this.board[i];\n            if (piece === undefined || piece.color !== us) {\n                continue;\n            }\n\n            if (piece.type === PieceType.PAWN) {\n                /* single square, non-capturing */\n                const square1 = i + this.PAWN_OFFSETS[us][0];\n                if (this.board[square1] === undefined) {\n                    this.add_move(this.board, moves, i, square1, this.BITS.NORMAL);\n\n                    /* double square */\n                    const square = i + this.PAWN_OFFSETS[us][1];\n                    if (second_rank[us] === this.rank(i) && this.board[square] === undefined) {\n                        this.add_move(this.board, moves, i, square, this.BITS.BIG_PAWN);\n                    }\n                }\n\n                /* pawn captures */\n                for (let j = 2; j < 4; j++) {\n                    const square = i + this.PAWN_OFFSETS[us][j];\n                    if (square & 0x88) { continue; }\n\n                    if (this.board[square] !== undefined &&\n                        this.board[square].color === them) {\n                        this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                    } else if (square === this.ep_square) {\n                        this.add_move(this.board, moves, i, this.ep_square, this.BITS.EP_CAPTURE);\n                    }\n                }\n            } else {\n                for (let j = 0, len = this.PIECE_OFFSETS[piece.type].length; j < len; j++) {\n                    const offset = this.PIECE_OFFSETS[piece.type][j];\n                    let square = i;\n\n                    while (true) {\n                        square += offset;\n                        if (square & 0x88) { break; }\n\n                        if (this.board[square] === undefined) {\n                            this.add_move(this.board, moves, i, square, this.BITS.NORMAL);\n                        } else {\n                            if (this.board[square].color === us) { break; }\n                            this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                            break;\n                        }\n\n                        /* break, if knight or king */\n                        if (piece.type === 'n' || piece.type === 'k') { break; }\n                    }\n                }\n            }\n        }\n\n        /* check for castling if: a) we're generating all moves, or b) we're doing\n         * single square move generation on the king's square\n         */\n        if ((!single_square) || last_sq === this.kings[us]) {\n            /* king-side castling */\n            if (this.castling[us] & this.BITS.KSIDE_CASTLE) {\n                const castling_from = this.kings[us];\n                const castling_to = castling_from + 2;\n\n                if (this.board[castling_from + 1] === undefined &&\n                    this.board[castling_to] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from + 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to,\n                        this.BITS.KSIDE_CASTLE);\n                }\n            }\n\n            /* queen-side castling */\n            if (this.castling[us] & this.BITS.QSIDE_CASTLE) {\n                const castling_from = this.kings[us];\n                const castling_to = castling_from - 2;\n\n                if (this.board[castling_from - 1] === undefined &&\n                    this.board[castling_from - 2] === undefined &&\n                    this.board[castling_from - 3] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from - 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to,\n                        this.BITS.QSIDE_CASTLE);\n                }\n            }\n        }\n\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves;\n        }\n\n        /* filter out illegal moves */\n        const legal_moves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(us)) {\n                legal_moves.push(moves[i]);\n            }\n            this.undo_move();\n        }\n\n        return legal_moves;\n    }\n\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n     * disambiguation bugs in Fritz and Chessbase.  See below:\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    move_to_san(move, sloppy?) {\n\n        let output = '';\n\n        if (move.flags & this.BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        } else {\n            const disambiguator = this.get_disambiguator(move, sloppy);\n\n            if (move.piece !== PieceType.PAWN) {\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n\n            if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n                if (move.piece === PieceType.PAWN) {\n                    output += this.algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n\n            output += this.algebraic(move.to);\n\n            if (move.flags & this.BITS.PROMOTION) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n\n        this.make_move(move);\n        if (this.in_check()) {\n            if (this.in_checkmate()) {\n                output += '#';\n            } else {\n                output += '+';\n            }\n        }\n        this.undo_move();\n\n        return output;\n    }\n\n    // parses all of the decorators out of a SAN string\n    stripped_san(move) {\n        return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n    }\n\n    attacked(color, square) {\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) { i += 7; continue; }\n\n            /* if empty square or wrong color */\n            if (this.board[i] === undefined || this.board[i].color !== color) { continue; }\n\n            const piece = this.board[i];\n            const difference = i - square;\n            const index = difference + 119;\n\n            if (this.ATTACKS[index] & (1 << this.SHIFTS[piece.type])) {\n                if (piece.type === PieceType.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === Colour.WHITE) { return true; }\n                    } else {\n                        if (piece.color === Colour.BLACK) { return true; }\n                    }\n                    continue;\n                }\n\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k') { return true; }\n\n                const offset = this.RAYS[index];\n                let j = i + offset;\n\n                let blocked = false;\n                while (j !== square) {\n                    if (this.board[j] !== undefined) { blocked = true; break; }\n                    j += offset;\n                }\n\n                if (!blocked) { return true; }\n            }\n        }\n\n        return false;\n    }\n\n    king_attacked(color) {\n        return this.attacked(this.swap_color(color), this.kings[color]);\n    }\n\n    public in_check() {\n        return this.king_attacked(this.turn);\n    }\n\n    public in_checkmate() {\n        return this.in_check() && this.generate_moves().length === 0;\n    }\n\n    public in_stalemate() {\n        return !this.in_check() && this.generate_moves().length === 0;\n    }\n\n    public insufficient_material() {\n        const pieces = {};\n        const bishops = [];\n        let num_pieces = 0;\n        let sq_color = 0;\n\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            sq_color = (sq_color + 1) % 2;\n            if (i & 0x88) { i += 7; continue; }\n\n            const piece = this.board[i];\n            if (piece) {\n                pieces[piece.type] = (piece.type in pieces) ?\n                    pieces[piece.type] + 1 : 1;\n                if (piece.type === PieceType.BISHOP) {\n                    bishops.push(sq_color);\n                }\n                num_pieces++;\n            }\n        }\n\n        /* k vs. k */\n        if (num_pieces === 2) { return true; } else if (num_pieces === 3 && (pieces[PieceType.BISHOP] === 1 ||\n            pieces[PieceType.KNIGHT] === 1)) { return true; } else if (num_pieces === pieces[PieceType.BISHOP] + 2) {\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) { return true; }\n        }\n\n        return false;\n    }\n\n    public in_threefold_repetition() {\n        /* TODO: while this function is fine for casual use, a better\n         * implementation would use a Zobrist key (instead of FEN). the\n         * Zobrist key would be maintained in the make_move/undo_move functions,\n         * avoiding the costly that we do below.\n         */\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n\n        while (true) {\n            const move = this.undo_move();\n            if (!move) { break; }\n            moves.push(move);\n        }\n\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            const fen = this.generate_fen().split(' ').slice(0, 4).join(' ');\n\n            /* has the position occurred three or move times */\n            positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n\n            if (!moves.length) {\n                break;\n            }\n            this.make_move(moves.pop());\n        }\n\n        return repetition;\n    }\n\n    push(move) {\n        this.history.push({\n            move: move,\n            kings: { b: this.kings.b, w: this.kings.w },\n            turn: this.turn,\n            castling: { b: this.castling.b, w: this.castling.w },\n            ep_square: this.ep_square,\n            half_moves: this.half_moves,\n            move_number: this.move_number\n        });\n    }\n\n    make_move(move) {\n        const us: Colour = this.turn;\n        const them = this.swap_color(us);\n        this.push(move);\n\n        this.board[move.to] = this.board[move.from];\n        this.board[move.from] = undefined;\n\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & this.BITS.EP_CAPTURE) {\n            if (this.turn === Colour.BLACK) {\n                this.board[move.to - 16] = undefined;\n            } else {\n                this.board[move.to + 16] = undefined;\n            }\n        }\n\n        /* if pawn promotion, replace with new piece */\n        if (move.flags & this.BITS.PROMOTION) {\n            this.board[move.to] = { type: move.promotion, color: us };\n        }\n\n        /* if we moved the king */\n        if (this.board[move.to].type === PieceType.KING) {\n            this.kings[this.board[move.to].color] = move.to;\n\n            /* if we castled, move the rook next to the king */\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                const castling_to = move.to - 1;\n                const castling_from = move.to + 1;\n                this.board[castling_to] = this.board[castling_from];\n                this.board[castling_from] = undefined;\n            } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                const castling_to2 = move.to + 1;\n                const castling_from2 = move.to - 2;\n                this.board[castling_to2] = this.board[castling_from2];\n                this.board[castling_from2] = undefined;\n            }\n\n            /* turn off castling */\n            this.castling[us] = '';\n        }\n\n        /* turn off castling if we move a rook */\n        if (this.castling[us]) {\n            for (let i = 0, len = this.ROOKS[us].length; i < len; i++) {\n                if (move.from === this.ROOKS[us][i].square &&\n                    this.castling[us] & this.ROOKS[us][i].flag) {\n                    this.castling[us] ^= this.ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n\n        /* turn off castling if we capture a rook */\n        if (this.castling[them]) {\n            for (let i = 0, len = this.ROOKS[them].length; i < len; i++) {\n                if (move.to === this.ROOKS[them][i].square &&\n                    this.castling[them] & this.ROOKS[them][i].flag) {\n                    this.castling[them] ^= this.ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n\n        /* if big pawn move, update the en passant square */\n        if (move.flags & this.BITS.BIG_PAWN) {\n            if (this.turn === 'b') {\n                this.ep_square = move.to - 16;\n            } else {\n                this.ep_square = move.to + 16;\n            }\n        } else {\n            this.ep_square = this.EMPTY;\n        }\n\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === PieceType.PAWN) {\n            this.half_moves = 0;\n        } else if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n            this.half_moves = 0;\n        } else {\n            this.half_moves++;\n        }\n\n        if (this.turn === Colour.BLACK) {\n            this.move_number++;\n        }\n        this.turn = this.swap_color(this.turn);\n    }\n\n    undo_move() {\n        const old = this.history.pop();\n        if (old === undefined) { return undefined; }\n\n        const move = old.move;\n        this.kings = old.kings;\n        this.turn = old.turn;\n        this.castling = old.castling;\n        this.ep_square = old.ep_square;\n        this.half_moves = old.half_moves;\n        this.move_number = old.move_number;\n\n        const us = this.turn;\n        const them = this.swap_color(this.turn);\n\n        this.board[move.from] = this.board[move.to];\n        this.board[move.from].type = move.piece;  // to undo any promotions\n        this.board[move.to] = undefined;\n\n        if (move.flags & this.BITS.CAPTURE) {\n            this.board[move.to] = { type: move.captured, color: them };\n        } else if (move.flags & this.BITS.EP_CAPTURE) {\n            let index;\n            if (us === Colour.BLACK) {\n                index = move.to - 16;\n            } else {\n                index = move.to + 16;\n            }\n            this.board[index] = { type: PieceType.PAWN, color: them };\n        }\n\n\n        if (move.flags & (this.BITS.KSIDE_CASTLE | this.BITS.QSIDE_CASTLE)) {\n            let castling_to, castling_from;\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                castling_to = move.to + 1;\n                castling_from = move.to - 1;\n            } else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                castling_to = move.to - 2;\n                castling_from = move.to + 1;\n            }\n\n            this.board[castling_to] = this.board[castling_from];\n            this.board[castling_from] = undefined;\n        }\n        return move;\n    }\n\n    /* this function is used to uniquely identify ambiguous moves */\n    get_disambiguator(move, sloppy) {\n        const moves = this.generate_moves({ legal: !sloppy });\n\n        const from = move.from;\n        const to = move.to;\n        const piece = move.piece;\n\n        let ambiguities = 0;\n        let same_rank = 0;\n        let same_file = 0;\n\n        for (let i = 0, len = moves.length; i < len; i++) {\n            const ambig_from = moves[i].from;\n            const ambig_to = moves[i].to;\n            const ambig_piece = moves[i].piece;\n\n            /* if a move of the same piece type ends on the same to square, we'll\n             * need to add a disambiguator to the algebraic notation\n             */\n            if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n                ambiguities++;\n\n                if (this.rank(from) === this.rank(ambig_from)) {\n                    same_rank++;\n                }\n\n                if (this.file(from) === this.file(ambig_from)) {\n                    same_file++;\n                }\n            }\n        }\n\n        if (ambiguities > 0) {\n            /* if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            if (same_rank > 0 && same_file > 0) {\n                return this.algebraic(from);\n            } else if (same_file > 0) {\n                return this.algebraic(from).charAt(1);\n            } else {\n                return this.algebraic(from).charAt(0);\n            }\n        }\n\n        return '';\n    }\n\n    public ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* display the rank */\n            if (this.file(i) === 0) {\n                s += ' ' + '87654321'[this.rank(i)] + ' |';\n            }\n\n            /* empty piece */\n            if (this.board[i] === undefined) {\n                s += ' . ';\n            } else {\n                const piece = this.board[i].type;\n                const color = this.board[i].color;\n                const symbol = (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h\\n';\n\n        return s;\n    }\n\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    move_from_san(move, sloppy) {\n        // strip off any move decorations: e.g Nf3+?!\n        const clean_move = this.stripped_san(move);\n\n        // if we're using the sloppy parser run a regex to grab piece, to, and from\n        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n        const matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        let piece;\n        let from;\n        let to;\n        let promotion;\n        if (sloppy) {\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n            }\n        }\n\n        const moves = this.generate_moves();\n        for (let i = 0, len = moves.length; i < len; i++) {\n            // try the strict parser first, then the sloppy parser if requested\n            // by the user\n            if ((clean_move === this.stripped_san(this.move_to_san(moves[i]))) ||\n                (sloppy && clean_move === this.stripped_san(this.move_to_san(moves[i], true)))) {\n                return moves[i];\n            } else {\n                if (matches &&\n                    (!piece || piece.toLowerCase() === moves[i].piece) &&\n                    this.SQUARES[from] === moves[i].from &&\n                    this.SQUARES[to] === moves[i].to &&\n                    (!promotion || promotion.toLowerCase() === moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n\n    /*****************************************************************************\n     * UTILITY FUNCTIONS\n     ****************************************************************************/\n    rank(i) {\n        return i >> 4;\n    }\n\n    file(i) {\n        return i & 15;\n    }\n\n    algebraic(i) {\n        const f = this.file(i), r = this.rank(i);\n        return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n    }\n\n    swap_color(c) {\n        return c === Colour.WHITE ? Colour.BLACK : Colour.WHITE;\n    }\n\n    is_digit(c) {\n        return '0123456789'.indexOf(c) !== -1;\n    }\n\n    /* pretty = external move object */\n    make_pretty(ugly_move) {\n        const move = this.clone(ugly_move);\n        move.san = this.move_to_san(move, false);\n        move.to = this.algebraic(move.to);\n        move.from = this.algebraic(move.from);\n\n        let flags = '';\n\n        for (const flag in this.BITS) {\n            if (this.BITS[flag] & move.flags) {\n                flags += this.FLAGS[flag];\n            }\n        }\n        move.flags = flags;\n\n        return move;\n    }\n\n    clone(obj) {\n        const dupe: any = (obj instanceof Array) ? [] : {};\n\n        for (const property in obj) {\n            if (typeof property === 'object') {\n                dupe[property] = this.clone(obj[property]);\n            } else {\n                dupe[property] = obj[property];\n            }\n        }\n\n        return dupe;\n    }\n\n    trim(str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    /*****************************************************************************\n     * DEBUGGING UTILITIES\n     ****************************************************************************/\n    public perft(depth) {\n        const moves = this.generate_moves({ legal: false });\n        let nodes = 0;\n        const color = this.turn;\n\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(color)) {\n                if (depth - 1 > 0) {\n                    const child_nodes = this.perft(depth - 1);\n                    nodes += child_nodes;\n                } else {\n                    nodes++;\n                }\n            }\n            this.undo_move();\n        }\n\n        return nodes;\n    }\n\n    public getSquares() {\n        /* from the ECMA-262 spec (section 12.6.4):\n         * \"The mechanics of enumerating the properties ... is\n         * implementation dependent\"\n         * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n         * ordered correctly\n         */\n        const keys = [];\n        for (let i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (i & 0x88) { i += 7; continue; }\n            keys.push(this.algebraic(i));\n        }\n        return keys;\n    }\n\n    public getMoves(options) {\n        /* The internal representation of a chess move is in 0x88 format, and\n                 * not meant to be human-readable.  The code below converts the 0x88\n                 * square coordinates to algebraic coordinates.  It also prunes an\n                 * unnecessary move keys resulting from a verbose call.\n                 */\n\n        const ugly_moves = this.generate_moves(options);\n        const moves = [];\n\n        for (let i = 0, len = ugly_moves.length; i < len; i++) {\n\n            /* does the user want a full move object (most likely not), or just\n             * SAN\n             */\n            if (typeof options !== 'undefined' && 'verbose' in options &&\n                options.verbose) {\n                moves.push(this.make_pretty(ugly_moves[i]));\n            } else {\n                moves.push(this.move_to_san(ugly_moves[i], false));\n            }\n        }\n\n        return moves;\n    }\n\n    public get in_draw() {\n        return this.half_moves >= 100 ||\n            this.in_stalemate() ||\n            this.insufficient_material() ||\n            this.in_threefold_repetition();\n    }\n\n    public get game_over() {\n        return this.half_moves >= 100 ||\n            this.in_checkmate() ||\n            this.in_stalemate() ||\n            this.insufficient_material() ||\n            this.in_threefold_repetition();\n    }\n\n    public get fen() {\n        return this.generate_fen();\n    }\n\n    public getPgn(options) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n                 * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n                 */\n        const newline = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\n';\n        const max_width = (typeof options === 'object' &&\n            typeof options.max_width === 'number') ?\n            options.max_width : 0;\n        const result = [];\n        let header_exists = false;\n\n        /* add the PGN header headerrmation */\n        for (const i in this.header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \\\"' + this.header[i] + '\\\"]' + newline);\n            header_exists = true;\n        }\n\n        if (header_exists && history.length) {\n            result.push(newline);\n        }\n\n        /* pop all of history onto reversed_history */\n        const reversed_history = [];\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n\n        const moves = [];\n        let move_string = '';\n\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversed_history.length > 0) {\n            const move = reversed_history.pop();\n\n            /* if the position started with black to move, start PGN with 1. ... */\n            if (!history.length && move.color === 'b') {\n                move_string = this.move_number + '. ...';\n            } else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (move_string.length) {\n                    moves.push(move_string);\n                }\n                move_string = this.move_number + '.';\n            }\n\n            move_string = move_string + ' ' + this.move_to_san(move, false);\n            this.make_move(move);\n        }\n\n        /* are there any other leftover moves? */\n        if (move_string.length) {\n            moves.push(move_string);\n        }\n\n        /* is there a result? */\n        if (typeof this.header.Result !== 'undefined') {\n            moves.push(this.header.Result);\n        }\n\n        /* history should be back to what is was before we started generating PGN,\n         * so join together moves\n         */\n        if (max_width === 0) {\n            return result.join('') + moves.join(' ');\n        }\n\n        /* wrap the PGN output at max_width */\n        let current_width = 0;\n        for (let i2 = 0; i2 < moves.length; i2++) {\n            /* if the current move will push past max_width */\n            if (current_width + moves[i2].length > max_width && i2 !== 0) {\n\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n\n                result.push(newline);\n                current_width = 0;\n            } else if (i2 !== 0) {\n                result.push(' ');\n                current_width++;\n            }\n            result.push(moves[i2]);\n            current_width += moves[i2].length;\n        }\n\n        return result.join('');\n    }\n\n    public load_pgn(pgn, options) {\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        const sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n\n        function has_keys(object) {\n            for (const key in object) {\n                return true;\n            }\n            return false;\n        }\n\n        function parse_pgn_header(header, hOptions) {\n            const hNewline_char = (typeof hOptions === 'object' &&\n                typeof hOptions.newline_char === 'string') ?\n                hOptions.newline_char : '\\r?\\n';\n            const header_obj = {};\n            const lHeaders = header.split(new RegExp(mask(hNewline_char)));\n            let key = '';\n            let value = '';\n\n            for (let i = 0; i < lHeaders.length; i++) {\n                key = lHeaders[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n                value = lHeaders[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1');\n                if (this.trim(key).length > 0) {\n                    header_obj[key] = value;\n                }\n            }\n\n            return header_obj;\n        }\n\n        const newline_char = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\r?\\n';\n        const regex = new RegExp('^(\\\\[(.|' + mask(newline_char) + ')*\\\\])' +\n            '(' + mask(newline_char) + ')*' +\n            '1.(' + mask(newline_char) + '|.)*$', 'g');\n\n        /* get header part of the PGN file */\n        let header_string = pgn.replace(regex, '$1');\n\n        /* no info part given, begins with moves */\n        if (header_string[0] !== '[') {\n            header_string = '';\n        }\n\n        this.reset();\n\n        /* parse PGN header */\n        const headers = parse_pgn_header(header_string, options);\n        for (const key in headers) {\n            this.set_header([key, headers[key]]);\n        }\n\n        /* load the starting position indicated by [Setup '1'] and\n        * [FEN position] */\n        if (headers['SetUp'] === '1') {\n            if (!(('FEN' in headers) && this.load(headers['FEN']))) {\n                return false;\n            }\n        }\n\n        /* delete header to get the moves */\n        let ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');\n\n        /* delete comments */\n        ms = ms.replace(/(\\{[^}]+\\})+?/g, '');\n\n        /* delete recursive annotation variations */\n        const rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n        while (rav_regex.test(ms)) {\n            ms = ms.replace(rav_regex, '');\n        }\n\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n\n        /* trim and get array of moves */\n        let moves = this.trim(ms).split(new RegExp(/\\s+/));\n\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        let move = '';\n\n        for (let half_move = 0; half_move < moves.length - 1; half_move++) {\n            move = this.move_from_san(moves[half_move], sloppy);\n\n            /* move not possible! (don't clear the board to examine to show the\n             * latest valid position)\n             */\n            if (move === undefined) {\n                return false;\n            } else {\n                this.make_move(move);\n            }\n        }\n\n        /* examine last move */\n        move = moves[moves.length - 1];\n        if (this.POSSIBLE_RESULTS.indexOf(move) > -1) {\n            if (has_keys(this.header) && typeof this.header.Result === 'undefined') {\n                this.set_header(['Result', move]);\n            }\n        } else {\n            move = this.move_from_san(move, sloppy);\n            if (move === undefined) {\n                return false;\n            } else {\n                this.make_move(move);\n            }\n        }\n        return true;\n    }\n\n    public getHeader() {\n        return this.set_header(arguments);\n    }\n\n    public move(move: Move | string, options?) {\n        /* The move function can be called with in the following parameters:\n                 *\n                 * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n                 *\n                 * .move({ from: 'h7', <- where the 'move' is a move object (additional\n                 *         to :'h8',      fields are ignored)\n                 *         promotion: 'q',\n                 *      })\n                 */\n\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        const sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n\n        let move_obj;\n\n        if (typeof move === 'string') {\n            move_obj = this.move_from_san(move, sloppy);\n        } else if (typeof move === 'object') {\n            const moves = this.generate_moves();\n\n            /* convert the pretty move object to an ugly move object */\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === this.algebraic(moves[i].from) &&\n                    move.to === this.algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) ||\n                        move.promotion === moves[i].promotion)) {\n                    move_obj = moves[i];\n                    break;\n                }\n            }\n        }\n\n        /* failed to find move */\n        if (!move_obj) {\n            return undefined;\n        }\n\n        /* need to make a copy of move because we can't generate SAN after the\n         * move is made\n         */\n        const pretty_move = this.make_pretty(move_obj);\n\n        this.make_move(move_obj);\n        this.onChange.emit();\n        return pretty_move;\n    }\n\n    public undo() {\n        const move = this.undo_move();\n        this.onChange.emit();\n        return (move) ? this.make_pretty(move) : undefined;\n    }\n\n    public square_color(square) {\n        if (square in this.SQUARES) {\n            const sq_0x88 = this.SQUARES[square];\n            return ((this.rank(sq_0x88) + this.file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';\n        }\n\n        return undefined;\n    }\n\n    public getHistory(options) {\n        const reversed_history = [];\n        const move_history = [];\n        const verbose = (typeof options !== 'undefined' && 'verbose' in options &&\n            options.verbose);\n\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n\n        while (reversed_history.length > 0) {\n            const move = reversed_history.pop();\n            if (verbose) {\n                move_history.push(this.make_pretty(move));\n            } else {\n                move_history.push(this.move_to_san(move));\n            }\n            this.make_move(move);\n        }\n\n        return move_history;\n    }\n\n} // End of Chess class\n\nexport class FenValidationResult {\n    // { valid: true, error_number: 0, error: errors[0] };\n    valid: boolean;\n    error_number: number;\n    error: string;\n}\n\nexport class ChessPiece {\n    color;\n    type;\n}\n\n// enum Colour {\n//     WHITE = 'w',\n//     BLACK = 'b'\n// }\n\nclass Castling {\n    w: any;\n    b: any;\n}\n\n\n\n\n"]}