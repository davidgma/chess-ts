{"version":3,"sources":["/./dist/chess-ts/fesm5/chess-ts.js","/./src/app/app.component.html","/./src/$_lazy_route_resource lazy namespace object","/./src/app/app.component.css","/./src/app/app.component.ts","/./src/app/app.module.ts","/./src/environments/environment.ts","/./src/main.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;;AAE7C;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAwD;AACzE,iBAAiB,wDAAwD;AACzE,iBAAiB,wDAAwD;AACzE,iBAAiB,wDAAwD;AACzE;AACA;AACA,sBAAsB;AACtB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sBAAsB;AACtB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,0BAA0B,0CAA0C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,2BAA2B;AAC3B,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF,+BAA+B,EAAE;AACjC;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA,uBAAuB,yCAAyC;AAChE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mCAAmC;AACnC;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,yCAAyC,iBAAiB;AAC1D,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,2CAA2C,SAAS;AACpD,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,yCAAyC,eAAe;AACxD,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe,EAAE;AACjE;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,yDAAyD,wCAAwC;AACjG;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,4BAA4B,GAAG,IAAI;AACnC;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;;AAE2E;AAC3E;;;;;;;;;;;;ACvgEA,mJAAmJ,SAAS,oGAAoG,QAAQ,iC;;;;;;;;;;;ACAxQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,4CAA4C,WAAW;AACvD;AACA;AACA,4E;;;;;;;;;;;ACZA,4BAA4B,4BAA4B,4BAA4B,2BAA2B,wBAAwB,4BAA4B,GAAG,6CAA6C,ue;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAjK;AACjB;AAOjC;IALA;QAME,UAAK,GAAG,cAAc,CAAC;QACvB,WAAM,GAAG,IAAI,KAAK,EAAU,CAAC;IAQ/B,CAAC;IANO,+BAAQ,GAAd;;;;;gBACM,CAAC,GAAG,IAAI,OAAO,CAAO,UAAC,OAAO;oBAChC,IAAI,KAAK,GAAG,IAAI,8CAAK,EAAE,CAAC;oBACxB,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;gBACjD,CAAC,CAAC,CAAC;;;;KACJ;IATU,YAAY;QALxB,+DAAS,CAAC;YACT,QAAQ,EAAE,UAAU;YACpB,uIAAmC;;SAEpC,CAAC;OACW,YAAY,CAUxB;IAAD,mBAAC;CAAA;AAVwB;;;;;;;;;;;;;;;;;;;;;;;;ACRiC;AACjB;AAEM;AAY/C;IAAA;IAAyB,CAAC;IAAb,SAAS;QAVrB,8DAAQ,CAAC;YACR,YAAY,EAAE;gBACZ,2DAAY;aACb;YACD,OAAO,EAAE;gBACP,uEAAa;aACd;YACD,SAAS,EAAE,EAAE;YACb,SAAS,EAAE,CAAC,2DAAY,CAAC;SAC1B,CAAC;OACW,SAAS,CAAI;IAAD,gBAAC;CAAA;AAAJ;;;;;;;;;;;;;ACftB;AAAA;AAAA,gFAAgF;AAChF,2EAA2E;AAC3E,gEAAgE;AAEzD,IAAM,WAAW,GAAG;IACzB,UAAU,EAAE,KAAK;CAClB,CAAC;AAEF;;;;;GAKG;AACH,mEAAmE;;;;;;;;;;;;;ACdnE;AAAA;AAAA;AAAA;AAAA;AAA+C;AAC4B;AAE9B;AACY;AAEzD,IAAI,qEAAW,CAAC,UAAU,EAAE;IAC1B,oEAAc,EAAE,CAAC;CAClB;AAED,gGAAsB,EAAE,CAAC,eAAe,CAAC,yDAAS,CAAC;KAChD,KAAK,CAAC,aAAG,IAAI,cAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAhB,CAAgB,CAAC,CAAC","file":"main.js","sourcesContent":["import { EventEmitter } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/* todo:\n    make async and sync alternatives to the calling.\n    bring enums into the chess.ts file.\n    fix public/private variables\n    make sure everything has an explicit type\n    create separate classes game, fen, piece\n    fix the todos\n    add documentation and generate API doc\n*/\n/** @enum {string} */\nvar Colour = {\n    WHITE: 'w',\n    BLACK: 'b',\n};\n/** @enum {string} */\nvar PieceType = {\n    PAWN: 'p',\n    KNIGHT: 'n',\n    BISHOP: 'b',\n    ROOK: 'r',\n    QUEEN: 'q',\n    KING: 'k',\n};\nvar Move = /** @class */ (function () {\n    function Move(from, to, promotion) {\n        this.from = from;\n        this.to = to;\n        this.promotion = promotion;\n    }\n    return Move;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Chess = /** @class */ (function () {\n    function Chess(fen) {\n        this.EMPTY = -1;\n        this.onChange = new EventEmitter();\n        this.SYMBOLS = 'pnbrqkPNBRQK';\n        this.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n        this.POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n        this.PAWN_OFFSETS = {\n            b: [16, 32, 17, 15],\n            w: [-16, -32, -17, -15]\n        };\n        this.PIECE_OFFSETS = {\n            n: [-18, -33, -31, -14, 18, 33, 31, 14],\n            b: [-17, -15, 17, 15],\n            r: [-16, 1, 16, -1],\n            q: [-17, -16, -15, 1, 17, 16, 15, -1],\n            k: [-17, -16, -15, 1, 17, 16, 15, -1]\n        };\n        this.ATTACKS = [\n            20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n            0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n            0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n            0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n            0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n            24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n            0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n            0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n            0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n            0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n            20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n        ];\n        this.RAYS = [\n            17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n            0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n            0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n            0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n            0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n            1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n            0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n            0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n            0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n            0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n            -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n        ];\n        this.SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };\n        this.FLAGS = {\n            NORMAL: 'n',\n            CAPTURE: 'c',\n            BIG_PAWN: 'b',\n            EP_CAPTURE: 'e',\n            PROMOTION: 'p',\n            KSIDE_CASTLE: 'k',\n            QSIDE_CASTLE: 'q'\n        };\n        this.BITS = {\n            NORMAL: 1,\n            CAPTURE: 2,\n            BIG_PAWN: 4,\n            EP_CAPTURE: 8,\n            PROMOTION: 16,\n            KSIDE_CASTLE: 32,\n            QSIDE_CASTLE: 64\n        };\n        this.RANK_1 = 7;\n        this.RANK_2 = 6;\n        this.RANK_3 = 5;\n        this.RANK_4 = 4;\n        this.RANK_5 = 3;\n        this.RANK_6 = 2;\n        this.RANK_7 = 1;\n        this.RANK_8 = 0;\n        this.SQUARES = {\n            a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n            a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n            a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n            a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n            a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n            a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n            a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n            a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n        };\n        this.ROOKS = {\n            w: [{ square: this.SQUARES.a1, flag: this.BITS.QSIDE_CASTLE },\n                { square: this.SQUARES.h1, flag: this.BITS.KSIDE_CASTLE }],\n            b: [{ square: this.SQUARES.a8, flag: this.BITS.QSIDE_CASTLE },\n                { square: this.SQUARES.h8, flag: this.BITS.KSIDE_CASTLE }]\n        };\n        this.board = new Array(128);\n        this.kings = { w: this.EMPTY, b: this.EMPTY };\n        this.turn = Colour.WHITE;\n        this.castling = { w: 0, b: 0 };\n        this.ep_square = this.EMPTY;\n        this.half_moves = 0;\n        this.move_number = 1;\n        this.history = [];\n        this.header = {};\n        /* if the user passes in a fen string, load it, else default to\n         * starting position\n         */\n        if (typeof fen === 'undefined') {\n            this.load(this.DEFAULT_POSITION);\n        }\n        else {\n            this.load(fen);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    Chess.prototype.clear = /**\n     * @return {?}\n     */\n    function () {\n        this.board = new Array(128);\n        this.kings = { w: this.EMPTY, b: this.EMPTY };\n        this.turn = Colour.WHITE;\n        this.castling = { w: 0, b: 0 };\n        this.ep_square = this.EMPTY;\n        this.half_moves = 0;\n        this.move_number = 1;\n        this.history = [];\n        this.header = {};\n        this.update_setup(this.generate_fen());\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        this.load(this.DEFAULT_POSITION);\n    };\n    /**\n     * @param {?} fen\n     * @return {?}\n     */\n    Chess.prototype.load = /**\n     * @param {?} fen\n     * @return {?}\n     */\n    function (fen) {\n        /** @type {?} */\n        var tokens = fen.split(/\\s+/);\n        /** @type {?} */\n        var position = tokens[0];\n        /** @type {?} */\n        var square = 0;\n        if (!this.validate_fen(fen).valid) {\n            return false;\n        }\n        this.clear();\n        for (var i = 0; i < position.length; i++) {\n            /** @type {?} */\n            var piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (this.is_digit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                /** @type {?} */\n                var color = (piece < 'a') ? Colour.WHITE : Colour.BLACK;\n                this.put({ type: piece.toLowerCase(), color: color }, this.algebraic(square));\n                square++;\n            }\n        }\n        this.turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this.castling.w |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this.castling.w |= this.BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this.castling.b |= this.BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this.castling.b |= this.BITS.QSIDE_CASTLE;\n        }\n        this.ep_square = (tokens[3] === '-') ? this.EMPTY : this.SQUARES[tokens[3]];\n        this.half_moves = parseInt(tokens[4], 10);\n        this.move_number = parseInt(tokens[5], 10);\n        this.update_setup(this.generate_fen());\n        this.onChange.emit();\n        return true;\n    };\n    /* TODO: this function is pretty much crap - it validates structure but\n     * completely ignores content (e.g. doesn't verify that each side has a king)\n     * ... we should rewrite this, and ditch the silly error_number field while\n     * we're at it\n     */\n    /* TODO: this function is pretty much crap - it validates structure but\n         * completely ignores content (e.g. doesn't verify that each side has a king)\n         * ... we should rewrite this, and ditch the silly error_number field while\n         * we're at it\n         */\n    /**\n     * @param {?} fen\n     * @return {?}\n     */\n    Chess.prototype.validate_fen = /* TODO: this function is pretty much crap - it validates structure but\n         * completely ignores content (e.g. doesn't verify that each side has a king)\n         * ... we should rewrite this, and ditch the silly error_number field while\n         * we're at it\n         */\n    /**\n     * @param {?} fen\n     * @return {?}\n     */\n    function (fen) {\n        /** @type {?} */\n        var errors = {\n            0: 'No errors.',\n            1: 'FEN string must contain six space-delimited fields.',\n            2: '6th field (move number) must be a positive integer.',\n            3: '5th field (half move counter) must be a non-negative integer.',\n            4: '4th field (en-passant square) is invalid.',\n            5: '3rd field (castling availability) is invalid.',\n            6: '2nd field (side to move) is invalid.',\n            7: '1st field (piece positions) does not contain 8 \\'/\\'-delimited rows.',\n            8: '1st field (piece positions) is invalid [consecutive numbers].',\n            9: '1st field (piece positions) is invalid [invalid piece].',\n            10: '1st field (piece positions) is invalid [row too large].',\n            11: 'Illegal en-passant square',\n        };\n        /* 1st criterion: 6 space-seperated fields? */\n        /** @type {?} */\n        var tokens = fen.split(/\\s+/);\n        if (tokens.length !== 6) {\n            return { valid: false, error_number: 1, error: errors[1] };\n        }\n        /* 2nd criterion: move number field is a integer value > 0? */\n        if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {\n            return { valid: false, error_number: 2, error: errors[2] };\n        }\n        /* 3rd criterion: half move counter is an integer >= 0? */\n        if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {\n            return { valid: false, error_number: 3, error: errors[3] };\n        }\n        /* 4th criterion: 4th field is a valid e.p.-string? */\n        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n            return { valid: false, error_number: 4, error: errors[4] };\n        }\n        /* 5th criterion: 3th field is a valid castle-string? */\n        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n            return { valid: false, error_number: 5, error: errors[5] };\n        }\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n        if (!/^(w|b)$/.test(tokens[1])) {\n            return { valid: false, error_number: 6, error: errors[6] };\n        }\n        /* 7th criterion: 1st field contains 8 rows? */\n        /** @type {?} */\n        var rows = tokens[0].split('/');\n        if (rows.length !== 8) {\n            return { valid: false, error_number: 7, error: errors[7] };\n        }\n        /* 8th criterion: every row is valid? */\n        for (var i = 0; i < rows.length; i++) {\n            /* check for right sum of fields AND not two numbers in succession */\n            /** @type {?} */\n            var sum_fields = 0;\n            /** @type {?} */\n            var previous_was_number = false;\n            for (var k = 0; k < rows[i].length; k++) {\n                if (!isNaN(rows[i][k])) {\n                    if (previous_was_number) {\n                        return { valid: false, error_number: 8, error: errors[8] };\n                    }\n                    sum_fields += parseInt(rows[i][k], 10);\n                    previous_was_number = true;\n                }\n                else {\n                    if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                        return { valid: false, error_number: 9, error: errors[9] };\n                    }\n                    sum_fields += 1;\n                    previous_was_number = false;\n                }\n            }\n            if (sum_fields !== 8) {\n                return { valid: false, error_number: 10, error: errors[10] };\n            }\n        }\n        if ((tokens[3][1] === '3' && tokens[1] === 'w') ||\n            (tokens[3][1] === '6' && tokens[1] === 'b')) {\n            return { valid: false, error_number: 11, error: errors[11] };\n        }\n        /* everything's okay! */\n        return { valid: true, error_number: 0, error: errors[0] };\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.generate_fen = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var empty = 0;\n        /** @type {?} */\n        var fen = '';\n        for (var i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (this.board[i] === undefined) {\n                empty++;\n            }\n            else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                /** @type {?} */\n                var color = this.board[i].color;\n                /** @type {?} */\n                var piece = this.board[i].type;\n                fen += (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== this.SQUARES.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        /** @type {?} */\n        var cflags = '';\n        if (this.castling[Colour.WHITE] & this.BITS.KSIDE_CASTLE) {\n            cflags += 'K';\n        }\n        if (this.castling[Colour.WHITE] & this.BITS.QSIDE_CASTLE) {\n            cflags += 'Q';\n        }\n        if (this.castling[Colour.BLACK] & this.BITS.KSIDE_CASTLE) {\n            cflags += 'k';\n        }\n        if (this.castling[Colour.BLACK] & this.BITS.QSIDE_CASTLE) {\n            cflags += 'q';\n        }\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        /** @type {?} */\n        var epflags = (this.ep_square === this.EMPTY) ? '-' : this.algebraic(this.ep_square);\n        return [fen, this.turn, cflags, epflags, this.half_moves, this.move_number].join(' ');\n    };\n    /**\n     * @param {?} args\n     * @return {?}\n     */\n    Chess.prototype.set_header = /**\n     * @param {?} args\n     * @return {?}\n     */\n    function (args) {\n        for (var i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' &&\n                typeof args[i + 1] === 'string') {\n                this.header[args[i]] = args[i + 1];\n            }\n        }\n        return this.header;\n    };\n    /* called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\n     * equal to the default position, the SetUp and FEN are deleted\n     * the setup is only updated if history.length is zero, ie moves haven't been\n     * made.\n     */\n    /* called when the initial board setup is changed with put() or remove().\n         * modifies the SetUp and FEN properties of the header object.  if the FEN is\n         * equal to the default position, the SetUp and FEN are deleted\n         * the setup is only updated if history.length is zero, ie moves haven't been\n         * made.\n         */\n    /**\n     * @param {?} fen\n     * @return {?}\n     */\n    Chess.prototype.update_setup = /* called when the initial board setup is changed with put() or remove().\n         * modifies the SetUp and FEN properties of the header object.  if the FEN is\n         * equal to the default position, the SetUp and FEN are deleted\n         * the setup is only updated if history.length is zero, ie moves haven't been\n         * made.\n         */\n    /**\n     * @param {?} fen\n     * @return {?}\n     */\n    function (fen) {\n        if (history.length > 0) {\n            return;\n        }\n        if (fen !== this.DEFAULT_POSITION) {\n            this.header['SetUp'] = '1';\n            this.header['FEN'] = fen;\n        }\n        else {\n            delete this.header['SetUp'];\n            delete this.header['FEN'];\n        }\n    };\n    /**\n     * @param {?} square\n     * @return {?}\n     */\n    Chess.prototype.get = /**\n     * @param {?} square\n     * @return {?}\n     */\n    function (square) {\n        /** @type {?} */\n        var piece = this.board[this.SQUARES[square]];\n        return (piece) ? { type: piece.type, color: piece.color } : undefined;\n    };\n    /**\n     * @param {?} piece\n     * @param {?} square\n     * @return {?}\n     */\n    Chess.prototype.put = /**\n     * @param {?} piece\n     * @param {?} square\n     * @return {?}\n     */\n    function (piece, square) {\n        /* check for valid piece object */\n        if (!('type' in piece && 'color' in piece)) {\n            return false;\n        }\n        /* check for piece */\n        if (this.SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n            return false;\n        }\n        /* check for valid square */\n        if (!(square in this.SQUARES)) {\n            return false;\n        }\n        /** @type {?} */\n        var sq = this.SQUARES[square];\n        /* don't let the user place more than one king */\n        if (piece.type === PieceType.KING &&\n            !(this.kings[piece.color] === this.EMPTY || this.kings[piece.color] === sq)) {\n            return false;\n        }\n        this.board[sq] = { type: piece.type, color: piece.color };\n        if (piece.type === PieceType.KING) {\n            this.kings[piece.color] = sq;\n        }\n        this.update_setup(this.generate_fen());\n        return true;\n    };\n    /**\n     * @param {?} square\n     * @return {?}\n     */\n    Chess.prototype.remove = /**\n     * @param {?} square\n     * @return {?}\n     */\n    function (square) {\n        /** @type {?} */\n        var piece = this.get(square);\n        this.board[this.SQUARES[square]] = undefined;\n        if (piece && piece.type === PieceType.KING) {\n            this.kings[piece.color] = this.EMPTY;\n        }\n        this.update_setup(this.generate_fen());\n        return piece;\n    };\n    /**\n     * @param {?} board\n     * @param {?} from\n     * @param {?} to\n     * @param {?} flags\n     * @param {?=} promotion\n     * @return {?}\n     */\n    Chess.prototype.build_move = /**\n     * @param {?} board\n     * @param {?} from\n     * @param {?} to\n     * @param {?} flags\n     * @param {?=} promotion\n     * @return {?}\n     */\n    function (board, from, to, flags, promotion) {\n        /** @type {?} */\n        var move = {\n            color: this.turn,\n            from: from,\n            to: to,\n            flags: flags,\n            piece: board[from].type,\n            // dgm: these needed to exist for typescript\n            promotion: undefined,\n            captured: undefined\n        };\n        if (promotion) {\n            move.flags |= this.BITS.PROMOTION;\n            move.promotion = promotion;\n        }\n        if (board[to]) {\n            move.captured = board[to].type;\n        }\n        else if (flags & this.BITS.EP_CAPTURE) {\n            move.captured = PieceType.PAWN;\n        }\n        return move;\n    };\n    /**\n     * @private\n     * @param {?} board\n     * @param {?} moves\n     * @param {?} from\n     * @param {?} to\n     * @param {?} flags\n     * @return {?}\n     */\n    Chess.prototype.add_move = /**\n     * @private\n     * @param {?} board\n     * @param {?} moves\n     * @param {?} from\n     * @param {?} to\n     * @param {?} flags\n     * @return {?}\n     */\n    function (board, moves, from, to, flags) {\n        /* if pawn promotion */\n        if (board[from].type === PieceType.PAWN &&\n            (this.rank(to) === this.RANK_8 || this.rank(to) === this.RANK_1)) {\n            /** @type {?} */\n            var pieces = [PieceType.QUEEN, PieceType.ROOK, PieceType.BISHOP, PieceType.KNIGHT];\n            for (var i = 0, len = pieces.length; i < len; i++) {\n                moves.push(this.build_move(board, from, to, flags, pieces[i]));\n            }\n        }\n        else {\n            moves.push(this.build_move(board, from, to, flags));\n        }\n    };\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    Chess.prototype.generate_moves = /**\n     * @param {?=} options\n     * @return {?}\n     */\n    function (options) {\n        /** @type {?} */\n        var moves = [];\n        /** @type {?} */\n        var us = this.turn;\n        /** @type {?} */\n        var them = this.swap_color(us);\n        /** @type {?} */\n        var second_rank = { b: this.RANK_7, w: this.RANK_2 };\n        /** @type {?} */\n        var first_sq = this.SQUARES.a8;\n        /** @type {?} */\n        var last_sq = this.SQUARES.h1;\n        /** @type {?} */\n        var single_square = false;\n        /* do we want legal moves? */\n        /** @type {?} */\n        var legal = (typeof options !== 'undefined' && 'legal' in options) ?\n            options.legal : true;\n        /* are we generating moves for a single square? */\n        if (typeof options !== 'undefined' && 'square' in options) {\n            if (options.square in this.SQUARES) {\n                first_sq = last_sq = this.SQUARES[options.square];\n                single_square = true;\n            }\n            else {\n                /* invalid square */\n                return [];\n            }\n        }\n        for (var i = first_sq; i <= last_sq; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /** @type {?} */\n            var piece = this.board[i];\n            if (piece === undefined || piece.color !== us) {\n                continue;\n            }\n            if (piece.type === PieceType.PAWN) {\n                /* single square, non-capturing */\n                /** @type {?} */\n                var square1 = i + this.PAWN_OFFSETS[us][0];\n                if (this.board[square1] === undefined) {\n                    this.add_move(this.board, moves, i, square1, this.BITS.NORMAL);\n                    /* double square */\n                    /** @type {?} */\n                    var square = i + this.PAWN_OFFSETS[us][1];\n                    if (second_rank[us] === this.rank(i) && this.board[square] === undefined) {\n                        this.add_move(this.board, moves, i, square, this.BITS.BIG_PAWN);\n                    }\n                }\n                /* pawn captures */\n                for (var j = 2; j < 4; j++) {\n                    /** @type {?} */\n                    var square = i + this.PAWN_OFFSETS[us][j];\n                    if (square & 0x88) {\n                        continue;\n                    }\n                    if (this.board[square] !== undefined &&\n                        this.board[square].color === them) {\n                        this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                    }\n                    else if (square === this.ep_square) {\n                        this.add_move(this.board, moves, i, this.ep_square, this.BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                for (var j = 0, len = this.PIECE_OFFSETS[piece.type].length; j < len; j++) {\n                    /** @type {?} */\n                    var offset = this.PIECE_OFFSETS[piece.type][j];\n                    /** @type {?} */\n                    var square = i;\n                    while (true) {\n                        square += offset;\n                        if (square & 0x88) {\n                            break;\n                        }\n                        if (this.board[square] === undefined) {\n                            this.add_move(this.board, moves, i, square, this.BITS.NORMAL);\n                        }\n                        else {\n                            if (this.board[square].color === us) {\n                                break;\n                            }\n                            this.add_move(this.board, moves, i, square, this.BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (piece.type === 'n' || piece.type === 'k') {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        /* check for castling if: a) we're generating all moves, or b) we're doing\n         * single square move generation on the king's square\n         */\n        if ((!single_square) || last_sq === this.kings[us]) {\n            /* king-side castling */\n            if (this.castling[us] & this.BITS.KSIDE_CASTLE) {\n                /** @type {?} */\n                var castling_from = this.kings[us];\n                /** @type {?} */\n                var castling_to = castling_from + 2;\n                if (this.board[castling_from + 1] === undefined &&\n                    this.board[castling_to] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from + 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to, this.BITS.KSIDE_CASTLE);\n                }\n            }\n            /* queen-side castling */\n            if (this.castling[us] & this.BITS.QSIDE_CASTLE) {\n                /** @type {?} */\n                var castling_from = this.kings[us];\n                /** @type {?} */\n                var castling_to = castling_from - 2;\n                if (this.board[castling_from - 1] === undefined &&\n                    this.board[castling_from - 2] === undefined &&\n                    this.board[castling_from - 3] === undefined &&\n                    !this.attacked(them, this.kings[us]) &&\n                    !this.attacked(them, castling_from - 1) &&\n                    !this.attacked(them, castling_to)) {\n                    this.add_move(this.board, moves, this.kings[us], castling_to, this.BITS.QSIDE_CASTLE);\n                }\n            }\n        }\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves;\n        }\n        /* filter out illegal moves */\n        /** @type {?} */\n        var legal_moves = [];\n        for (var i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(us)) {\n                legal_moves.push(moves[i]);\n            }\n            this.undo_move();\n        }\n        return legal_moves;\n    };\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n     * disambiguation bugs in Fritz and Chessbase.  See below:\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n         * (SAN)\n         *\n         * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n         * disambiguation bugs in Fritz and Chessbase.  See below:\n         *\n         * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n         * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n         * 4. ... Ne7 is technically the valid SAN\n         */\n    /**\n     * @param {?} move\n     * @param {?=} sloppy\n     * @return {?}\n     */\n    Chess.prototype.move_to_san = /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n         * (SAN)\n         *\n         * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n         * disambiguation bugs in Fritz and Chessbase.  See below:\n         *\n         * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n         * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n         * 4. ... Ne7 is technically the valid SAN\n         */\n    /**\n     * @param {?} move\n     * @param {?=} sloppy\n     * @return {?}\n     */\n    function (move, sloppy) {\n        /** @type {?} */\n        var output = '';\n        if (move.flags & this.BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & this.BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            /** @type {?} */\n            var disambiguator = this.get_disambiguator(move, sloppy);\n            if (move.piece !== PieceType.PAWN) {\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n                if (move.piece === PieceType.PAWN) {\n                    output += this.algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += this.algebraic(move.to);\n            if (move.flags & this.BITS.PROMOTION) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this.make_move(move);\n        if (this.in_check()) {\n            if (this.in_checkmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this.undo_move();\n        return output;\n    };\n    // parses all of the decorators out of a SAN string\n    // parses all of the decorators out of a SAN string\n    /**\n     * @param {?} move\n     * @return {?}\n     */\n    Chess.prototype.stripped_san = \n    // parses all of the decorators out of a SAN string\n    /**\n     * @param {?} move\n     * @return {?}\n     */\n    function (move) {\n        return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n    };\n    /**\n     * @param {?} color\n     * @param {?} square\n     * @return {?}\n     */\n    Chess.prototype.attacked = /**\n     * @param {?} color\n     * @param {?} square\n     * @return {?}\n     */\n    function (color, square) {\n        for (var i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /* if empty square or wrong color */\n            if (this.board[i] === undefined || this.board[i].color !== color) {\n                continue;\n            }\n            /** @type {?} */\n            var piece = this.board[i];\n            /** @type {?} */\n            var difference = i - square;\n            /** @type {?} */\n            var index = difference + 119;\n            if (this.ATTACKS[index] & (1 << this.SHIFTS[piece.type])) {\n                if (piece.type === PieceType.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === Colour.WHITE) {\n                            return true;\n                        }\n                    }\n                    else {\n                        if (piece.color === Colour.BLACK) {\n                            return true;\n                        }\n                    }\n                    continue;\n                }\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k') {\n                    return true;\n                }\n                /** @type {?} */\n                var offset = this.RAYS[index];\n                /** @type {?} */\n                var j = i + offset;\n                /** @type {?} */\n                var blocked = false;\n                while (j !== square) {\n                    if (this.board[j] !== undefined) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} color\n     * @return {?}\n     */\n    Chess.prototype.king_attacked = /**\n     * @param {?} color\n     * @return {?}\n     */\n    function (color) {\n        return this.attacked(this.swap_color(color), this.kings[color]);\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.in_check = /**\n     * @return {?}\n     */\n    function () {\n        return this.king_attacked(this.turn);\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.in_checkmate = /**\n     * @return {?}\n     */\n    function () {\n        return this.in_check() && this.generate_moves().length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.in_stalemate = /**\n     * @return {?}\n     */\n    function () {\n        return !this.in_check() && this.generate_moves().length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.insufficient_material = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var pieces = {};\n        /** @type {?} */\n        var bishops = [];\n        /** @type {?} */\n        var num_pieces = 0;\n        /** @type {?} */\n        var sq_color = 0;\n        for (var i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            sq_color = (sq_color + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /** @type {?} */\n            var piece = this.board[i];\n            if (piece) {\n                pieces[piece.type] = (piece.type in pieces) ?\n                    pieces[piece.type] + 1 : 1;\n                if (piece.type === PieceType.BISHOP) {\n                    bishops.push(sq_color);\n                }\n                num_pieces++;\n            }\n        }\n        /* k vs. k */\n        if (num_pieces === 2) {\n            return true;\n        }\n        else if (num_pieces === 3 && (pieces[PieceType.BISHOP] === 1 ||\n            pieces[PieceType.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (num_pieces === pieces[PieceType.BISHOP] + 2) {\n            /** @type {?} */\n            var sum = 0;\n            /** @type {?} */\n            var len = bishops.length;\n            for (var i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.in_threefold_repetition = /**\n     * @return {?}\n     */\n    function () {\n        /* TODO: while this function is fine for casual use, a better\n                 * implementation would use a Zobrist key (instead of FEN). the\n                 * Zobrist key would be maintained in the make_move/undo_move functions,\n                 * avoiding the costly that we do below.\n                 */\n        /** @type {?} */\n        var moves = [];\n        /** @type {?} */\n        var positions = {};\n        /** @type {?} */\n        var repetition = false;\n        while (true) {\n            /** @type {?} */\n            var move = this.undo_move();\n            if (!move) {\n                break;\n            }\n            moves.push(move);\n        }\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n                         * when checking for draw by rep */\n            /** @type {?} */\n            var fen = this.generate_fen().split(' ').slice(0, 4).join(' ');\n            /* has the position occurred three or move times */\n            positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            if (!moves.length) {\n                break;\n            }\n            this.make_move(moves.pop());\n        }\n        return repetition;\n    };\n    /**\n     * @param {?} move\n     * @return {?}\n     */\n    Chess.prototype.push = /**\n     * @param {?} move\n     * @return {?}\n     */\n    function (move) {\n        this.history.push({\n            move: move,\n            kings: { b: this.kings.b, w: this.kings.w },\n            turn: this.turn,\n            castling: { b: this.castling.b, w: this.castling.w },\n            ep_square: this.ep_square,\n            half_moves: this.half_moves,\n            move_number: this.move_number\n        });\n    };\n    /**\n     * @param {?} move\n     * @return {?}\n     */\n    Chess.prototype.make_move = /**\n     * @param {?} move\n     * @return {?}\n     */\n    function (move) {\n        /** @type {?} */\n        var us = this.turn;\n        /** @type {?} */\n        var them = this.swap_color(us);\n        this.push(move);\n        this.board[move.to] = this.board[move.from];\n        this.board[move.from] = undefined;\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & this.BITS.EP_CAPTURE) {\n            if (this.turn === Colour.BLACK) {\n                this.board[move.to - 16] = undefined;\n            }\n            else {\n                this.board[move.to + 16] = undefined;\n            }\n        }\n        /* if pawn promotion, replace with new piece */\n        if (move.flags & this.BITS.PROMOTION) {\n            this.board[move.to] = { type: move.promotion, color: us };\n        }\n        /* if we moved the king */\n        if (this.board[move.to].type === PieceType.KING) {\n            this.kings[this.board[move.to].color] = move.to;\n            /* if we castled, move the rook next to the king */\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                /** @type {?} */\n                var castling_to = move.to - 1;\n                /** @type {?} */\n                var castling_from = move.to + 1;\n                this.board[castling_to] = this.board[castling_from];\n                this.board[castling_from] = undefined;\n            }\n            else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                /** @type {?} */\n                var castling_to2 = move.to + 1;\n                /** @type {?} */\n                var castling_from2 = move.to - 2;\n                this.board[castling_to2] = this.board[castling_from2];\n                this.board[castling_from2] = undefined;\n            }\n            /* turn off castling */\n            this.castling[us] = '';\n        }\n        /* turn off castling if we move a rook */\n        if (this.castling[us]) {\n            for (var i = 0, len = this.ROOKS[us].length; i < len; i++) {\n                if (move.from === this.ROOKS[us][i].square &&\n                    this.castling[us] & this.ROOKS[us][i].flag) {\n                    this.castling[us] ^= this.ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        /* turn off castling if we capture a rook */\n        if (this.castling[them]) {\n            for (var i = 0, len = this.ROOKS[them].length; i < len; i++) {\n                if (move.to === this.ROOKS[them][i].square &&\n                    this.castling[them] & this.ROOKS[them][i].flag) {\n                    this.castling[them] ^= this.ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        /* if big pawn move, update the en passant square */\n        if (move.flags & this.BITS.BIG_PAWN) {\n            if (this.turn === 'b') {\n                this.ep_square = move.to - 16;\n            }\n            else {\n                this.ep_square = move.to + 16;\n            }\n        }\n        else {\n            this.ep_square = this.EMPTY;\n        }\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === PieceType.PAWN) {\n            this.half_moves = 0;\n        }\n        else if (move.flags & (this.BITS.CAPTURE | this.BITS.EP_CAPTURE)) {\n            this.half_moves = 0;\n        }\n        else {\n            this.half_moves++;\n        }\n        if (this.turn === Colour.BLACK) {\n            this.move_number++;\n        }\n        this.turn = this.swap_color(this.turn);\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.undo_move = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var old = this.history.pop();\n        if (old === undefined) {\n            return undefined;\n        }\n        /** @type {?} */\n        var move = old.move;\n        this.kings = old.kings;\n        this.turn = old.turn;\n        this.castling = old.castling;\n        this.ep_square = old.ep_square;\n        this.half_moves = old.half_moves;\n        this.move_number = old.move_number;\n        /** @type {?} */\n        var us = this.turn;\n        /** @type {?} */\n        var them = this.swap_color(this.turn);\n        this.board[move.from] = this.board[move.to];\n        this.board[move.from].type = move.piece; // to undo any promotions\n        this.board[move.to] = undefined;\n        if (move.flags & this.BITS.CAPTURE) {\n            this.board[move.to] = { type: move.captured, color: them };\n        }\n        else if (move.flags & this.BITS.EP_CAPTURE) {\n            /** @type {?} */\n            var index = void 0;\n            if (us === Colour.BLACK) {\n                index = move.to - 16;\n            }\n            else {\n                index = move.to + 16;\n            }\n            this.board[index] = { type: PieceType.PAWN, color: them };\n        }\n        if (move.flags & (this.BITS.KSIDE_CASTLE | this.BITS.QSIDE_CASTLE)) {\n            /** @type {?} */\n            var castling_to = void 0;\n            /** @type {?} */\n            var castling_from = void 0;\n            if (move.flags & this.BITS.KSIDE_CASTLE) {\n                castling_to = move.to + 1;\n                castling_from = move.to - 1;\n            }\n            else if (move.flags & this.BITS.QSIDE_CASTLE) {\n                castling_to = move.to - 2;\n                castling_from = move.to + 1;\n            }\n            this.board[castling_to] = this.board[castling_from];\n            this.board[castling_from] = undefined;\n        }\n        return move;\n    };\n    /* this function is used to uniquely identify ambiguous moves */\n    /* this function is used to uniquely identify ambiguous moves */\n    /**\n     * @param {?} move\n     * @param {?} sloppy\n     * @return {?}\n     */\n    Chess.prototype.get_disambiguator = /* this function is used to uniquely identify ambiguous moves */\n    /**\n     * @param {?} move\n     * @param {?} sloppy\n     * @return {?}\n     */\n    function (move, sloppy) {\n        /** @type {?} */\n        var moves = this.generate_moves({ legal: !sloppy });\n        /** @type {?} */\n        var from = move.from;\n        /** @type {?} */\n        var to = move.to;\n        /** @type {?} */\n        var piece = move.piece;\n        /** @type {?} */\n        var ambiguities = 0;\n        /** @type {?} */\n        var same_rank = 0;\n        /** @type {?} */\n        var same_file = 0;\n        for (var i = 0, len = moves.length; i < len; i++) {\n            /** @type {?} */\n            var ambig_from = moves[i].from;\n            /** @type {?} */\n            var ambig_to = moves[i].to;\n            /** @type {?} */\n            var ambig_piece = moves[i].piece;\n            /* if a move of the same piece type ends on the same to square, we'll\n             * need to add a disambiguator to the algebraic notation\n             */\n            if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n                ambiguities++;\n                if (this.rank(from) === this.rank(ambig_from)) {\n                    same_rank++;\n                }\n                if (this.file(from) === this.file(ambig_from)) {\n                    same_file++;\n                }\n            }\n        }\n        if (ambiguities > 0) {\n            /* if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            if (same_rank > 0 && same_file > 0) {\n                return this.algebraic(from);\n            }\n            else if (same_file > 0) {\n                return this.algebraic(from).charAt(1);\n            }\n            else {\n                return this.algebraic(from).charAt(0);\n            }\n        }\n        return '';\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.ascii = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var s = '   +------------------------+\\n';\n        for (var i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            /* display the rank */\n            if (this.file(i) === 0) {\n                s += ' ' + '87654321'[this.rank(i)] + ' |';\n            }\n            /* empty piece */\n            if (this.board[i] === undefined) {\n                s += ' . ';\n            }\n            else {\n                /** @type {?} */\n                var piece = this.board[i].type;\n                /** @type {?} */\n                var color = this.board[i].color;\n                /** @type {?} */\n                var symbol = (color === Colour.WHITE) ?\n                    piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h\\n';\n        return s;\n    };\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    /**\n     * @param {?} move\n     * @param {?} sloppy\n     * @return {?}\n     */\n    Chess.prototype.move_from_san = \n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    /**\n     * @param {?} move\n     * @param {?} sloppy\n     * @return {?}\n     */\n    function (move, sloppy) {\n        // strip off any move decorations: e.g Nf3+?!\n        /** @type {?} */\n        var clean_move = this.stripped_san(move);\n        // if we're using the sloppy parser run a regex to grab piece, to, and from\n        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n        /** @type {?} */\n        var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        /** @type {?} */\n        var piece;\n        /** @type {?} */\n        var from;\n        /** @type {?} */\n        var to;\n        /** @type {?} */\n        var promotion;\n        if (sloppy) {\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n            }\n        }\n        /** @type {?} */\n        var moves = this.generate_moves();\n        for (var i = 0, len = moves.length; i < len; i++) {\n            // try the strict parser first, then the sloppy parser if requested\n            // by the user\n            if ((clean_move === this.stripped_san(this.move_to_san(moves[i]))) ||\n                (sloppy && clean_move === this.stripped_san(this.move_to_san(moves[i], true)))) {\n                return moves[i];\n            }\n            else {\n                if (matches &&\n                    (!piece || piece.toLowerCase() === moves[i].piece) &&\n                    this.SQUARES[from] === moves[i].from &&\n                    this.SQUARES[to] === moves[i].to &&\n                    (!promotion || promotion.toLowerCase() === moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return undefined;\n    };\n    /*****************************************************************************\n     * UTILITY FUNCTIONS\n     ****************************************************************************/\n    /**\n     * **************************************************************************\n     * UTILITY FUNCTIONS\n     * **************************************************************************\n     * @param {?} i\n     * @return {?}\n     */\n    Chess.prototype.rank = /**\n     * **************************************************************************\n     * UTILITY FUNCTIONS\n     * **************************************************************************\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return i >> 4;\n    };\n    /**\n     * @param {?} i\n     * @return {?}\n     */\n    Chess.prototype.file = /**\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return i & 15;\n    };\n    /**\n     * @param {?} i\n     * @return {?}\n     */\n    Chess.prototype.algebraic = /**\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        /** @type {?} */\n        var f = this.file(i);\n        /** @type {?} */\n        var r = this.rank(i);\n        return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n    };\n    /**\n     * @param {?} c\n     * @return {?}\n     */\n    Chess.prototype.swap_color = /**\n     * @param {?} c\n     * @return {?}\n     */\n    function (c) {\n        return c === Colour.WHITE ? Colour.BLACK : Colour.WHITE;\n    };\n    /**\n     * @param {?} c\n     * @return {?}\n     */\n    Chess.prototype.is_digit = /**\n     * @param {?} c\n     * @return {?}\n     */\n    function (c) {\n        return '0123456789'.indexOf(c) !== -1;\n    };\n    /* pretty = external move object */\n    /* pretty = external move object */\n    /**\n     * @param {?} ugly_move\n     * @return {?}\n     */\n    Chess.prototype.make_pretty = /* pretty = external move object */\n    /**\n     * @param {?} ugly_move\n     * @return {?}\n     */\n    function (ugly_move) {\n        /** @type {?} */\n        var move = this.clone(ugly_move);\n        move.san = this.move_to_san(move, false);\n        move.to = this.algebraic(move.to);\n        move.from = this.algebraic(move.from);\n        /** @type {?} */\n        var flags = '';\n        for (var flag in this.BITS) {\n            if (this.BITS[flag] & move.flags) {\n                flags += this.FLAGS[flag];\n            }\n        }\n        move.flags = flags;\n        return move;\n    };\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    Chess.prototype.clone = /**\n     * @param {?} obj\n     * @return {?}\n     */\n    function (obj) {\n        /** @type {?} */\n        var dupe = (obj instanceof Array) ? [] : {};\n        for (var property in obj) {\n            if (typeof property === 'object') {\n                dupe[property] = this.clone(obj[property]);\n            }\n            else {\n                dupe[property] = obj[property];\n            }\n        }\n        return dupe;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    Chess.prototype.trim = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n    };\n    /*****************************************************************************\n     * DEBUGGING UTILITIES\n     ****************************************************************************/\n    /**\n     * **************************************************************************\n     * DEBUGGING UTILITIES\n     * **************************************************************************\n     * @param {?} depth\n     * @return {?}\n     */\n    Chess.prototype.perft = /**\n     * **************************************************************************\n     * DEBUGGING UTILITIES\n     * **************************************************************************\n     * @param {?} depth\n     * @return {?}\n     */\n    function (depth) {\n        /** @type {?} */\n        var moves = this.generate_moves({ legal: false });\n        /** @type {?} */\n        var nodes = 0;\n        /** @type {?} */\n        var color = this.turn;\n        for (var i = 0, len = moves.length; i < len; i++) {\n            this.make_move(moves[i]);\n            if (!this.king_attacked(color)) {\n                if (depth - 1 > 0) {\n                    /** @type {?} */\n                    var child_nodes = this.perft(depth - 1);\n                    nodes += child_nodes;\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this.undo_move();\n        }\n        return nodes;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.getSquares = /**\n     * @return {?}\n     */\n    function () {\n        /* from the ECMA-262 spec (section 12.6.4):\n                 * \"The mechanics of enumerating the properties ... is\n                 * implementation dependent\"\n                 * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n                 * ordered correctly\n                 */\n        /** @type {?} */\n        var keys = [];\n        for (var i = this.SQUARES.a8; i <= this.SQUARES.h1; i++) {\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            keys.push(this.algebraic(i));\n        }\n        return keys;\n    };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    Chess.prototype.getMoves = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        /* The internal representation of a chess move is in 0x88 format, and\n                 * not meant to be human-readable.  The code below converts the 0x88\n                 * square coordinates to algebraic coordinates.  It also prunes an\n                 * unnecessary move keys resulting from a verbose call.\n                 */\n        /* The internal representation of a chess move is in 0x88 format, and\n                         * not meant to be human-readable.  The code below converts the 0x88\n                         * square coordinates to algebraic coordinates.  It also prunes an\n                         * unnecessary move keys resulting from a verbose call.\n                         */\n        /** @type {?} */\n        var ugly_moves = this.generate_moves(options);\n        /** @type {?} */\n        var moves = [];\n        for (var i = 0, len = ugly_moves.length; i < len; i++) {\n            /* does the user want a full move object (most likely not), or just\n             * SAN\n             */\n            if (typeof options !== 'undefined' && 'verbose' in options &&\n                options.verbose) {\n                moves.push(this.make_pretty(ugly_moves[i]));\n            }\n            else {\n                moves.push(this.move_to_san(ugly_moves[i], false));\n            }\n        }\n        return moves;\n    };\n    Object.defineProperty(Chess.prototype, \"in_draw\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.half_moves >= 100 ||\n                this.in_stalemate() ||\n                this.insufficient_material() ||\n                this.in_threefold_repetition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chess.prototype, \"game_over\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.half_moves >= 100 ||\n                this.in_checkmate() ||\n                this.in_stalemate() ||\n                this.insufficient_material() ||\n                this.in_threefold_repetition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chess.prototype, \"fen\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.generate_fen();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    Chess.prototype.getPgn = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n                         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n                         */\n        /** @type {?} */\n        var newline = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\n';\n        /** @type {?} */\n        var max_width = (typeof options === 'object' &&\n            typeof options.max_width === 'number') ?\n            options.max_width : 0;\n        /** @type {?} */\n        var result = [];\n        /** @type {?} */\n        var header_exists = false;\n        /* add the PGN header headerrmation */\n        for (var i in this.header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \\\"' + this.header[i] + '\\\"]' + newline);\n            header_exists = true;\n        }\n        if (header_exists && history.length) {\n            result.push(newline);\n        }\n        /* pop all of history onto reversed_history */\n        /** @type {?} */\n        var reversed_history = [];\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n        /** @type {?} */\n        var moves = [];\n        /** @type {?} */\n        var move_string = '';\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversed_history.length > 0) {\n            /** @type {?} */\n            var move = reversed_history.pop();\n            /* if the position started with black to move, start PGN with 1. ... */\n            if (!history.length && move.color === 'b') {\n                move_string = this.move_number + '. ...';\n            }\n            else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (move_string.length) {\n                    moves.push(move_string);\n                }\n                move_string = this.move_number + '.';\n            }\n            move_string = move_string + ' ' + this.move_to_san(move, false);\n            this.make_move(move);\n        }\n        /* are there any other leftover moves? */\n        if (move_string.length) {\n            moves.push(move_string);\n        }\n        /* is there a result? */\n        if (typeof this.header.Result !== 'undefined') {\n            moves.push(this.header.Result);\n        }\n        /* history should be back to what is was before we started generating PGN,\n         * so join together moves\n         */\n        if (max_width === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        /* wrap the PGN output at max_width */\n        /** @type {?} */\n        var current_width = 0;\n        for (var i2 = 0; i2 < moves.length; i2++) {\n            /* if the current move will push past max_width */\n            if (current_width + moves[i2].length > max_width && i2 !== 0) {\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                current_width = 0;\n            }\n            else if (i2 !== 0) {\n                result.push(' ');\n                current_width++;\n            }\n            result.push(moves[i2]);\n            current_width += moves[i2].length;\n        }\n        return result.join('');\n    };\n    /**\n     * @param {?} pgn\n     * @param {?} options\n     * @return {?}\n     */\n    Chess.prototype.load_pgn = /**\n     * @param {?} pgn\n     * @param {?} options\n     * @return {?}\n     */\n    function (pgn, options) {\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        /** @type {?} */\n        var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n        /**\n         * @param {?} str\n         * @return {?}\n         */\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        /**\n         * @param {?} object\n         * @return {?}\n         */\n        function has_keys(object) {\n            for (var key in object) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * @param {?} header\n         * @param {?} hOptions\n         * @return {?}\n         */\n        function parse_pgn_header(header, hOptions) {\n            /** @type {?} */\n            var hNewline_char = (typeof hOptions === 'object' &&\n                typeof hOptions.newline_char === 'string') ?\n                hOptions.newline_char : '\\r?\\n';\n            /** @type {?} */\n            var header_obj = {};\n            /** @type {?} */\n            var lHeaders = header.split(new RegExp(mask(hNewline_char)));\n            /** @type {?} */\n            var key = '';\n            /** @type {?} */\n            var value = '';\n            for (var i = 0; i < lHeaders.length; i++) {\n                key = lHeaders[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n                value = lHeaders[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1');\n                if (this.trim(key).length > 0) {\n                    header_obj[key] = value;\n                }\n            }\n            return header_obj;\n        }\n        /** @type {?} */\n        var newline_char = (typeof options === 'object' &&\n            typeof options.newline_char === 'string') ?\n            options.newline_char : '\\r?\\n';\n        /** @type {?} */\n        var regex = new RegExp('^(\\\\[(.|' + mask(newline_char) + ')*\\\\])' +\n            '(' + mask(newline_char) + ')*' +\n            '1.(' + mask(newline_char) + '|.)*$', 'g');\n        /* get header part of the PGN file */\n        /** @type {?} */\n        var header_string = pgn.replace(regex, '$1');\n        /* no info part given, begins with moves */\n        if (header_string[0] !== '[') {\n            header_string = '';\n        }\n        this.reset();\n        /* parse PGN header */\n        /** @type {?} */\n        var headers = parse_pgn_header(header_string, options);\n        for (var key in headers) {\n            this.set_header([key, headers[key]]);\n        }\n        /* load the starting position indicated by [Setup '1'] and\n        * [FEN position] */\n        if (headers['SetUp'] === '1') {\n            if (!(('FEN' in headers) && this.load(headers['FEN']))) {\n                return false;\n            }\n        }\n        /* delete header to get the moves */\n        /** @type {?} */\n        var ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');\n        /* delete comments */\n        ms = ms.replace(/(\\{[^}]+\\})+?/g, '');\n        /* delete recursive annotation variations */\n        /** @type {?} */\n        var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n        while (rav_regex.test(ms)) {\n            ms = ms.replace(rav_regex, '');\n        }\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        /* trim and get array of moves */\n        /** @type {?} */\n        var moves = this.trim(ms).split(new RegExp(/\\s+/));\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        /** @type {?} */\n        var move = '';\n        for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n            move = this.move_from_san(moves[half_move], sloppy);\n            /* move not possible! (don't clear the board to examine to show the\n             * latest valid position)\n             */\n            if (move === undefined) {\n                return false;\n            }\n            else {\n                this.make_move(move);\n            }\n        }\n        /* examine last move */\n        move = moves[moves.length - 1];\n        if (this.POSSIBLE_RESULTS.indexOf(move) > -1) {\n            if (has_keys(this.header) && typeof this.header.Result === 'undefined') {\n                this.set_header(['Result', move]);\n            }\n        }\n        else {\n            move = this.move_from_san(move, sloppy);\n            if (move === undefined) {\n                return false;\n            }\n            else {\n                this.make_move(move);\n            }\n        }\n        return true;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.getHeader = /**\n     * @return {?}\n     */\n    function () {\n        return this.set_header(arguments);\n    };\n    /**\n     * @param {?} move\n     * @param {?=} options\n     * @return {?}\n     */\n    Chess.prototype.move = /**\n     * @param {?} move\n     * @param {?=} options\n     * @return {?}\n     */\n    function (move, options) {\n        /* The move function can be called with in the following parameters:\n                 *\n                 * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n                 *\n                 * .move({ from: 'h7', <- where the 'move' is a move object (additional\n                 *         to :'h8',      fields are ignored)\n                 *         promotion: 'q',\n                 *      })\n                 */\n        /* The move function can be called with in the following parameters:\n                         *\n                         * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n                         *\n                         * .move({ from: 'h7', <- where the 'move' is a move object (additional\n                         *         to :'h8',      fields are ignored)\n                         *         promotion: 'q',\n                         *      })\n                         */\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        /** @type {?} */\n        var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n            options.sloppy : false;\n        /** @type {?} */\n        var move_obj;\n        if (typeof move === 'string') {\n            move_obj = this.move_from_san(move, sloppy);\n        }\n        else if (typeof move === 'object') {\n            /** @type {?} */\n            var moves = this.generate_moves();\n            /* convert the pretty move object to an ugly move object */\n            for (var i = 0, len = moves.length; i < len; i++) {\n                if (move.from === this.algebraic(moves[i].from) &&\n                    move.to === this.algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) ||\n                        move.promotion === moves[i].promotion)) {\n                    move_obj = moves[i];\n                    break;\n                }\n            }\n        }\n        /* failed to find move */\n        if (!move_obj) {\n            return undefined;\n        }\n        /* need to make a copy of move because we can't generate SAN after the\n                 * move is made\n                 */\n        /** @type {?} */\n        var pretty_move = this.make_pretty(move_obj);\n        this.make_move(move_obj);\n        this.onChange.emit();\n        return pretty_move;\n    };\n    /**\n     * @return {?}\n     */\n    Chess.prototype.undo = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var move = this.undo_move();\n        this.onChange.emit();\n        return (move) ? this.make_pretty(move) : undefined;\n    };\n    /**\n     * @param {?} square\n     * @return {?}\n     */\n    Chess.prototype.square_color = /**\n     * @param {?} square\n     * @return {?}\n     */\n    function (square) {\n        if (square in this.SQUARES) {\n            /** @type {?} */\n            var sq_0x88 = this.SQUARES[square];\n            return ((this.rank(sq_0x88) + this.file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';\n        }\n        return undefined;\n    };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    Chess.prototype.getHistory = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        /** @type {?} */\n        var reversed_history = [];\n        /** @type {?} */\n        var move_history = [];\n        /** @type {?} */\n        var verbose = (typeof options !== 'undefined' && 'verbose' in options &&\n            options.verbose);\n        while (history.length > 0) {\n            reversed_history.push(this.undo_move());\n        }\n        while (reversed_history.length > 0) {\n            /** @type {?} */\n            var move = reversed_history.pop();\n            if (verbose) {\n                move_history.push(this.make_pretty(move));\n            }\n            else {\n                move_history.push(this.move_to_san(move));\n            }\n            this.make_move(move);\n        }\n        return move_history;\n    };\n    return Chess;\n}()); // End of Chess class\n// End of Chess class\nvar  \n// End of Chess class\nFenValidationResult = /** @class */ (function () {\n    function FenValidationResult() {\n    }\n    return FenValidationResult;\n}());\nvar ChessPiece = /** @class */ (function () {\n    function ChessPiece() {\n    }\n    return ChessPiece;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Chess, ChessPiece, Colour, FenValidationResult, Move, PieceType };\n//# sourceMappingURL=chess-ts.js.map\n","module.exports = \"<!--The content below is only a placeholder and can be replaced.-->\\n<div style=\\\"text-align:center\\\">\\n  <h1>\\n    Welcome to {{ title }}!\\n  </h1>\\n \\n  <section>\\n    <ul class=\\\"bullets\\\">\\n        <li *ngFor=\\\"let line of output\\\">{{ line }}</li>\\n    </ul>\\n</section>\\n\\n\"","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./src/$$_lazy_route_resource lazy recursive\";","module.exports = \".bullets {\\n    list-style-type: none;\\n    display: inline-block; \\n    font-weight: normal;\\n    padding-left: 5px;\\n    word-break: break-all;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYXBwLmNvbXBvbmVudC5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSxxQkFBcUI7SUFDckIscUJBQXFCO0lBQ3JCLG1CQUFtQjtJQUNuQixpQkFBaUI7SUFDakIscUJBQXFCO0FBQ3pCIiwiZmlsZSI6InNyYy9hcHAvYXBwLmNvbXBvbmVudC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuYnVsbGV0cyB7XG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgICB3b3JkLWJyZWFrOiBicmVhay1hbGw7XG59Il19 */\"","import { Component, OnInit } from '@angular/core';\nimport { Chess } from 'chess-ts';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  title = 'chess-ts-app';\n  output = new Array<string>();\n\n  async ngOnInit() {\n    let p = new Promise<void>((resolve) => {\n      let chess = new Chess();\n      this.output.push(\"Starting fen: \" + chess.fen);\n    });\n  }\n}\n","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build ---prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * In development mode, to ignore zone related error stack frames such as\n * `zone.run`, `zoneDelegate.invokeTask` for easier debugging, you can\n * import the following file, but please comment it out in production mode\n * because it will have performance impact when throw error\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n"],"sourceRoot":""}